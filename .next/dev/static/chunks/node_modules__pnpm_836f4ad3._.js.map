{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/b64.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromBase64(base64String: string): Uint8Array {\n    return Uint8Array.from(atob(base64String), (char) => char.charCodeAt(0));\n}\n\nconst CHUNK_SIZE = 8192;\nexport function toBase64(bytes: Uint8Array): string {\n    // Special-case the simple case for speed's sake.\n    if (bytes.length < CHUNK_SIZE) {\n        return btoa(String.fromCharCode(...bytes));\n    }\n\n    let output = '';\n    for (let i = 0; i < bytes.length; i += CHUNK_SIZE) {\n        const chunk = bytes.slice(i, i + CHUNK_SIZE);\n        output += String.fromCharCode(...chunk);\n    }\n\n    return btoa(output);\n}\n\n/** @deprecated use toBase64 instead */\nexport const toB64 = toBase64;\n\n/** @deprecated use fromBase64 instead */\nexport const fromB64 = fromBase64;\n"],"names":[],"mappings":";;;;;;;;;;AAIO,SAAS,WAAW,YAAA,EAAkC;IACzD,OAAO,WAAW,IAAA,CAAK,KAAK,YAAY,GAAG,CAAC,OAAS,KAAK,UAAA,CAAW,CAAC,CAAC;AAC3E;AAEA,MAAM,aAAa;AACZ,SAAS,SAAS,KAAA,EAA2B;IAEhD,IAAI,MAAM,MAAA,GAAS,YAAY;QAC3B,OAAO,KAAK,OAAO,YAAA,CAAa,GAAG,KAAK,CAAC;IAC7C;IAEA,IAAI,SAAS;IACb,IAAA,IAAS,IAAI,GAAG,IAAI,MAAM,MAAA,EAAQ,KAAK,WAAY;QAC/C,MAAM,QAAQ,MAAM,KAAA,CAAM,GAAG,IAAI,UAAU;QAC3C,UAAU,OAAO,YAAA,CAAa,GAAG,KAAK;IAC1C;IAEA,OAAO,KAAK,MAAM;AACtB;AAGO,MAAM,QAAQ;AAGd,MAAM,UAAU"}},
    {"offset": {"line": 37, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/b58.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport bs58 from 'bs58';\n\nexport const toBase58 = (buffer: Uint8Array) => bs58.encode(buffer);\nexport const fromBase58 = (str: string) => bs58.decode(str);\n\n/** @deprecated use toBase58 instead */\nexport const toB58 = toBase58;\n\n/** @deprecated use fromBase58 instead */\nexport const fromB58 = fromBase58;\n"],"names":[],"mappings":";;;;;;;;;;AAIA,OAAO,UAAU;;AAEV,MAAM,WAAW,CAAC,SAAuB,0MAAA,CAAK,MAAA,CAAO,MAAM;AAC3D,MAAM,aAAa,CAAC,MAAgB,0MAAA,CAAK,MAAA,CAAO,GAAG;AAGnD,MAAM,QAAQ;AAGd,MAAM,UAAU"}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/hex.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHex(hexStr: string): Uint8Array {\n    const normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n    const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;\n    const intArr = padded.match(/.{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n\n    return Uint8Array.from(intArr);\n}\n\nexport function toHex(bytes: Uint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n\n/** @deprecated use toHex instead */\nexport const toHEX = toHex;\n\n/** @deprecated use fromHex instead */\nexport const fromHEX = fromHex;\n"],"names":[],"mappings":";;;;;;;;;;AAIO,SAAS,QAAQ,MAAA,EAA4B;IAChD,MAAM,aAAa,OAAO,UAAA,CAAW,IAAI,IAAI,OAAO,KAAA,CAAM,CAAC,IAAI;IAC/D,MAAM,SAAS,WAAW,MAAA,GAAS,MAAM,IAAI,aAAa,CAAA,CAAA,EAAI,UAAU,CAAA,CAAA,CAAA;IACxE,MAAM,SAAS,OAAO,KAAA,CAAM,OAAO,GAAG,IAAI,CAAC,OAAS,SAAS,MAAM,EAAE,CAAC,KAAK,CAAC,CAAA;IAE5E,OAAO,WAAW,IAAA,CAAK,MAAM;AACjC;AAEO,SAAS,MAAM,KAAA,EAA2B;IAC7C,OAAO,MAAM,MAAA,CAAO,CAAC,KAAK,OAAS,MAAM,KAAK,QAAA,CAAS,EAAE,EAAE,QAAA,CAAS,GAAG,GAAG,GAAG,EAAE;AACnF;AAGO,MAAM,QAAQ;AAGd,MAAM,UAAU"}},
    {"offset": {"line": 86, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/uleb.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n    const arr = [];\n    let len = 0;\n\n    if (num === 0) {\n        return [0];\n    }\n\n    while (num > 0) {\n        arr[len] = num & 0x7f;\n        if ((num >>= 7)) {\n            arr[len] |= 0x80;\n        }\n        len += 1;\n    }\n\n    return arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n    value: number;\n    length: number;\n} {\n    let total = 0;\n    let shift = 0;\n    let len = 0;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const byte = arr[len];\n        len += 1;\n        total |= (byte & 0x7f) << shift;\n        if ((byte & 0x80) === 0) {\n            break;\n        }\n        shift += 7;\n    }\n\n    return {\n        value: total,\n        length: len,\n    };\n}\n"],"names":[],"mappings":";;;;;;AAMO,SAAS,WAAW,GAAA,EAAuB;IAC9C,MAAM,MAAM,CAAC,CAAA;IACb,IAAI,MAAM;IAEV,IAAI,QAAQ,GAAG;QACX,OAAO;YAAC,CAAC;SAAA;IACb;IAEA,MAAO,MAAM,EAAG;QACZ,GAAA,CAAI,GAAG,CAAA,GAAI,MAAM;QACjB,IAAK,QAAQ,GAAI;YACb,GAAA,CAAI,GAAG,CAAA,IAAK;QAChB;QACA,OAAO;IACX;IAEA,OAAO;AACX;AAIO,SAAS,WAAW,GAAA,EAGzB;IACE,IAAI,QAAQ;IACZ,IAAI,QAAQ;IACZ,IAAI,MAAM;IAGV,MAAO,KAAM;QACT,MAAM,OAAO,GAAA,CAAI,GAAG,CAAA;QACpB,OAAO;QACP,SAAA,CAAU,OAAO,GAAA,KAAS;QAC1B,IAAA,CAAK,OAAO,GAAA,MAAU,GAAG;YACrB;QACJ;QACA,SAAS;IACb;IAEA,OAAO;QACH,OAAO;QACP,QAAQ;IACZ;AACJ"}},
    {"offset": {"line": 133, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/reader.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n    private dataView: DataView;\n    private bytePosition: number = 0;\n\n    /**\n     * @param {Uint8Array} data Data to use as a buffer.\n     */\n    constructor(data: Uint8Array) {\n        this.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    }\n    /**\n     * Shift current cursor position by `bytes`.\n     *\n     * @param {Number} bytes Number of bytes to\n     * @returns {this} Self for possible chaining.\n     */\n    shift(bytes: number) {\n        this.bytePosition += bytes;\n        return this;\n    }\n    /**\n     * Read U8 value from the buffer and shift cursor by 1.\n     * @returns\n     */\n    read8(): number {\n        const value = this.dataView.getUint8(this.bytePosition);\n        this.shift(1);\n        return value;\n    }\n    /**\n     * Read U16 value from the buffer and shift cursor by 2.\n     * @returns\n     */\n    read16(): number {\n        const value = this.dataView.getUint16(this.bytePosition, true);\n        this.shift(2);\n        return value;\n    }\n    /**\n     * Read U32 value from the buffer and shift cursor by 4.\n     * @returns\n     */\n    read32(): number {\n        const value = this.dataView.getUint32(this.bytePosition, true);\n        this.shift(4);\n        return value;\n    }\n    /**\n     * Read U64 value from the buffer and shift cursor by 8.\n     * @returns\n     */\n    read64(): string {\n        const value1 = this.read32();\n        const value2 = this.read32();\n\n        const result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read U128 value from the buffer and shift cursor by 16.\n     */\n    read128(): string {\n        const value1 = BigInt(this.read64());\n        const value2 = BigInt(this.read64());\n        const result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read U128 value from the buffer and shift cursor by 32.\n     * @returns\n     */\n    read256(): string {\n        const value1 = BigInt(this.read128());\n        const value2 = BigInt(this.read128());\n        const result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n        return BigInt('0x' + result).toString(10);\n    }\n    /**\n     * Read `num` number of bytes from the buffer and shift cursor by `num`.\n     * @param num Number of bytes to read.\n     */\n    readBytes(num: number): Uint8Array {\n        const start = this.bytePosition + this.dataView.byteOffset;\n        const value = new Uint8Array(this.dataView.buffer, start, num);\n\n        this.shift(num);\n\n        return value;\n    }\n    /**\n     * Read ULEB value - an integer of varying size. Used for enum indexes and\n     * vector lengths.\n     * @returns {Number} The ULEB value.\n     */\n    readULEB(): number {\n        const start = this.bytePosition + this.dataView.byteOffset;\n        const buffer = new Uint8Array(this.dataView.buffer, start);\n        const { value, length } = ulebDecode(buffer);\n\n        this.shift(length);\n\n        return value;\n    }\n    /**\n     * Read a BCS vector: read a length and then apply function `cb` X times\n     * where X is the length of the vector, defined as ULEB in BCS bytes.\n     * @param cb Callback to process elements of vector.\n     * @returns {Array<Any>} Array of the resulting values, returned by callback.\n     */\n    readVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n        const length = this.readULEB();\n        const result = [];\n        for (let i = 0; i < length; i++) {\n            result.push(cb(this, i, length));\n        }\n        return result;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 245, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/utils.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, toBase58 } from './b58.js';\nimport { fromBase64, toBase64 } from './b64.js';\nimport { fromHex, toHex } from './hex.js';\nimport type { Encoding } from './types.js';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n    switch (encoding) {\n        case 'base58':\n            return toBase58(data);\n        case 'base64':\n            return toBase64(data);\n        case 'hex':\n            return toHex(data);\n        default:\n            throw new Error('Unsupported encoding, supported values are: base64, hex');\n    }\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n    switch (encoding) {\n        case 'base58':\n            return fromBase58(data);\n        case 'base64':\n            return fromBase64(data);\n        case 'hex':\n            return fromHex(data);\n        default:\n            throw new Error('Unsupported encoding, supported values are: base64, hex');\n    }\n}\n\nexport function splitGenericParameters(\n    str: string,\n    genericSeparators: [string, string] = ['<', '>'],\n) {\n    const [left, right] = genericSeparators;\n    const tok = [];\n    let word = '';\n    let nestedAngleBrackets = 0;\n\n    for (let i = 0; i < str.length; i++) {\n        const char = str[i];\n        if (char === left) {\n            nestedAngleBrackets++;\n        }\n        if (char === right) {\n            nestedAngleBrackets--;\n        }\n        if (nestedAngleBrackets === 0 && char === ',') {\n            tok.push(word.trim());\n            word = '';\n            continue;\n        }\n        word += char;\n    }\n\n    tok.push(word.trim());\n\n    return tok;\n}\n"],"names":[],"mappings":";;;;;;;;AAIA,SAAS,YAAY,gBAAgB;AACrC,SAAS,YAAY,gBAAgB;AACrC,SAAS,SAAS,aAAa;;;;AAUxB,SAAS,UAAU,IAAA,EAAkB,QAAA,EAA4B;IACpE,OAAQ,UAAU;QACd,KAAK;YACD,WAAO,4NAAA,EAAS,IAAI;QACxB,KAAK;YACD,WAAO,4NAAA,EAAS,IAAI;QACxB,KAAK;YACD,WAAO,yNAAA,EAAM,IAAI;QACrB;YACI,MAAM,IAAI,MAAM,yDAAyD;IACjF;AACJ;AASO,SAAS,UAAU,IAAA,EAAc,QAAA,EAAgC;IACpE,OAAQ,UAAU;QACd,KAAK;YACD,WAAO,8NAAA,EAAW,IAAI;QAC1B,KAAK;YACD,WAAO,8NAAA,EAAW,IAAI;QAC1B,KAAK;YACD,WAAO,2NAAA,EAAQ,IAAI;QACvB;YACI,MAAM,IAAI,MAAM,yDAAyD;IACjF;AACJ;AAEO,SAAS,uBACZ,GAAA,EACA,oBAAsC;IAAC;IAAK,GAAG;CAAA,EACjD;IACE,MAAM,CAAC,MAAM,KAAK,CAAA,GAAI;IACtB,MAAM,MAAM,CAAC,CAAA;IACb,IAAI,OAAO;IACX,IAAI,sBAAsB;IAE1B,IAAA,IAAS,IAAI,GAAG,IAAI,IAAI,MAAA,EAAQ,IAAK;QACjC,MAAM,OAAO,GAAA,CAAI,CAAC,CAAA;QAClB,IAAI,SAAS,MAAM;YACf;QACJ;QACA,IAAI,SAAS,OAAO;YAChB;QACJ;QACA,IAAI,wBAAwB,KAAK,SAAS,KAAK;YAC3C,IAAI,IAAA,CAAK,KAAK,IAAA,CAAK,CAAC;YACpB,OAAO;YACP;QACJ;QACA,QAAQ;IACZ;IAEA,IAAI,IAAA,CAAK,KAAK,IAAA,CAAK,CAAC;IAEpB,OAAO;AACX"}},
    {"offset": {"line": 315, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/writer.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n    /** The initial size (in bytes) of the buffer that will be allocated */\n    initialSize?: number;\n    /** The maximum size (in bytes) that the buffer is allowed to grow to */\n    maxSize?: number;\n    /** The amount of bytes that will be allocated whenever additional memory is required */\n    allocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n    private dataView: DataView;\n    private bytePosition: number = 0;\n    private size: number;\n    private maxSize: number;\n    private allocateSize: number;\n\n    constructor({\n        initialSize = 1024,\n        maxSize = Infinity,\n        allocateSize = 1024,\n    }: BcsWriterOptions = {}) {\n        this.size = initialSize;\n        this.maxSize = maxSize;\n        this.allocateSize = allocateSize;\n        this.dataView = new DataView(new ArrayBuffer(initialSize));\n    }\n\n    private ensureSizeOrGrow(bytes: number) {\n        const requiredSize = this.bytePosition + bytes;\n        if (requiredSize > this.size) {\n            const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n            if (requiredSize > nextSize) {\n                throw new Error(\n                    `SizeLimitExceeded: Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n                );\n            }\n\n            this.size = nextSize;\n            const nextBuffer = new ArrayBuffer(this.size);\n            new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n            this.dataView = new DataView(nextBuffer);\n        }\n    }\n\n    /**\n     * Shift current cursor position by `bytes`.\n     *\n     * @param {Number} bytes Number of bytes to\n     * @returns {this} Self for possible chaining.\n     */\n    shift(bytes: number): this {\n        this.bytePosition += bytes;\n        return this;\n    }\n    /**\n     * Write a U8 value into a buffer and shift cursor position by 1.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write8(value: number | bigint): this {\n        this.ensureSizeOrGrow(1);\n        this.dataView.setUint8(this.bytePosition, Number(value));\n        return this.shift(1);\n    }\n    /**\n     * Write a U16 value into a buffer and shift cursor position by 2.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write16(value: number | bigint): this {\n        this.ensureSizeOrGrow(2);\n        this.dataView.setUint16(this.bytePosition, Number(value), true);\n        return this.shift(2);\n    }\n    /**\n     * Write a U32 value into a buffer and shift cursor position by 4.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    write32(value: number | bigint): this {\n        this.ensureSizeOrGrow(4);\n        this.dataView.setUint32(this.bytePosition, Number(value), true);\n        return this.shift(4);\n    }\n    /**\n     * Write a U64 value into a buffer and shift cursor position by 8.\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write64(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a U128 value into a buffer and shift cursor position by 16.\n     *\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write128(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a U256 value into a buffer and shift cursor position by 16.\n     *\n     * @param {bigint} value Value to write.\n     * @returns {this}\n     */\n    write256(value: number | bigint): this {\n        toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n        return this;\n    }\n    /**\n     * Write a ULEB value into a buffer and shift cursor position by number of bytes\n     * written.\n     * @param {Number} value Value to write.\n     * @returns {this}\n     */\n    writeULEB(value: number): this {\n        ulebEncode(value).forEach((el) => this.write8(el));\n        return this;\n    }\n    /**\n     * Write a vector into a buffer by first writing the vector length and then calling\n     * a callback on each passed value.\n     *\n     * @param {Array<Any>} vector Array of elements to write.\n     * @param {WriteVecCb} cb Callback to call on each element of the vector.\n     * @returns {this}\n     */\n    writeVec(\n        vector: any[],\n        cb: (writer: BcsWriter, el: any, i: number, len: number) => void,\n    ): this {\n        this.writeULEB(vector.length);\n        Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n        return this;\n    }\n\n    /**\n     * Adds support for iterations over the object.\n     * @returns {Uint8Array}\n     */\n    *[Symbol.iterator](): Iterator<number, Iterable<number>> {\n        for (let i = 0; i < this.bytePosition; i++) {\n            yield this.dataView.getUint8(i);\n        }\n        return this.toBytes();\n    }\n\n    /**\n     * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n     * @returns {Uint8Array} Resulting bcs.\n     */\n    toBytes(): Uint8Array {\n        return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n    }\n\n    /**\n     * Represent data as 'hex' or 'base64'\n     * @param encoding Encoding to use: 'base64' or 'hex'\n     */\n    toString(encoding: Encoding): string {\n        return encodeStr(this.toBytes(), encoding);\n    }\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n    const result = new Uint8Array(size);\n    let i = 0;\n    while (bigint > 0) {\n        result[i] = Number(bigint % BigInt(256));\n        bigint = bigint / BigInt(256);\n        i += 1;\n    }\n    return result;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 465, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/bcs-type.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, toBase58 } from './b58.js';\nimport { fromBase64, toBase64 } from './b64.js';\nimport { fromHex, toHex } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n    name?: string;\n    validate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n    $inferType!: T;\n    $inferInput!: Input;\n    name: string;\n    read: (reader: BcsReader) => T;\n    serializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n    validate: (value: Input) => void;\n    #write: (value: Input, writer: BcsWriter) => void;\n    #serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n    constructor(\n        options: {\n            name: string;\n            read: (reader: BcsReader) => T;\n            write: (value: Input, writer: BcsWriter) => void;\n            serialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n            serializedSize?: (value: Input) => number | null;\n            validate?: (value: Input) => void;\n        } & BcsTypeOptions<T, Input>,\n    ) {\n        this.name = options.name;\n        this.read = options.read;\n        this.serializedSize = options.serializedSize ?? (() => null);\n        this.#write = options.write;\n        this.#serialize =\n            options.serialize ??\n            ((value, options) => {\n                const writer = new BcsWriter({\n                    initialSize: this.serializedSize(value) ?? undefined,\n                    ...options,\n                });\n                this.#write(value, writer);\n                return writer.toBytes();\n            });\n\n        this.validate = options.validate ?? (() => {});\n    }\n\n    write(value: Input, writer: BcsWriter) {\n        this.validate(value);\n        this.#write(value, writer);\n    }\n\n    serialize(value: Input, options?: BcsWriterOptions) {\n        this.validate(value);\n        return new SerializedBcs(this, this.#serialize(value, options));\n    }\n\n    parse(bytes: Uint8Array): T {\n        const reader = new BcsReader(bytes);\n        return this.read(reader);\n    }\n\n    fromHex(hex: string) {\n        return this.parse(fromHex(hex));\n    }\n\n    fromBase58(b64: string) {\n        return this.parse(fromBase58(b64));\n    }\n\n    fromBase64(b64: string) {\n        return this.parse(fromBase64(b64));\n    }\n\n    transform<T2 = T, Input2 = Input>({\n        name,\n        input,\n        output,\n        validate,\n    }: {\n        input?: (val: Input2) => Input;\n        output?: (value: T) => T2;\n    } & BcsTypeOptions<T2, Input2>) {\n        return new BcsType<T2, Input2>({\n            name: name ?? this.name,\n            read: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n            write: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n            serializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n            serialize: (value, options) =>\n                this.#serialize(input ? input(value) : (value as never), options),\n            validate: (value) => {\n                validate?.(value);\n                this.validate(input ? input(value) : (value as never));\n            },\n        });\n    }\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@iota/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n    return !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n    #schema: BcsType<T, Input>;\n    #bytes: Uint8Array;\n\n    // Used to brand SerializedBcs so that they can be identified, even between multiple copies\n    // of the @iota/bcs package are installed\n    get [SERIALIZED_BCS_BRAND]() {\n        return true;\n    }\n\n    constructor(type: BcsType<T, Input>, schema: Uint8Array) {\n        this.#schema = type;\n        this.#bytes = schema;\n    }\n\n    toBytes() {\n        return this.#bytes;\n    }\n\n    toHex() {\n        return toHex(this.#bytes);\n    }\n\n    toBase64() {\n        return toBase64(this.#bytes);\n    }\n\n    toBase58() {\n        return toBase58(this.#bytes);\n    }\n\n    parse() {\n        return this.#schema.parse(this.#bytes);\n    }\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n    size,\n    ...options\n}: {\n    name: string;\n    size: number;\n    read: (reader: BcsReader) => T;\n    write: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n    return new BcsType<T, Input>({\n        ...options,\n        serializedSize: () => size,\n    });\n}\n\nexport function uIntBcsType({\n    readMethod,\n    writeMethod,\n    ...options\n}: {\n    name: string;\n    size: number;\n    readMethod: `read${8 | 16 | 32}`;\n    writeMethod: `write${8 | 16 | 32}`;\n    maxValue: number;\n} & BcsTypeOptions<number, number>) {\n    return fixedSizeBcsType<number>({\n        ...options,\n        read: (reader) => reader[readMethod](),\n        write: (value, writer) => writer[writeMethod](value),\n        validate: (value) => {\n            if (value < 0 || value > options.maxValue) {\n                throw new TypeError(\n                    `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n                );\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function bigUIntBcsType({\n    readMethod,\n    writeMethod,\n    ...options\n}: {\n    name: string;\n    size: number;\n    readMethod: `read${64 | 128 | 256}`;\n    writeMethod: `write${64 | 128 | 256}`;\n    maxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n    return fixedSizeBcsType<string, string | number | bigint>({\n        ...options,\n        read: (reader) => reader[readMethod](),\n        write: (value, writer) => writer[writeMethod](BigInt(value)),\n        validate: (val) => {\n            const value = BigInt(val);\n            if (value < 0 || value > options.maxValue) {\n                throw new TypeError(\n                    `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n                );\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n    serialize,\n    ...options\n}: {\n    name: string;\n    read: (reader: BcsReader) => T;\n    serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n    const type = new BcsType<T, Input>({\n        ...options,\n        serialize,\n        write: (value, writer) => {\n            for (const byte of type.serialize(value).toBytes()) {\n                writer.write8(byte);\n            }\n        },\n    });\n\n    return type;\n}\n\nexport function stringLikeBcsType({\n    toBytes,\n    fromBytes,\n    ...options\n}: {\n    name: string;\n    toBytes: (value: string) => Uint8Array;\n    fromBytes: (bytes: Uint8Array) => string;\n    serializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n    return new BcsType<string>({\n        ...options,\n        read: (reader) => {\n            const length = reader.readULEB();\n            const bytes = reader.readBytes(length);\n\n            return fromBytes(bytes);\n        },\n        write: (hex, writer) => {\n            const bytes = toBytes(hex);\n            writer.writeULEB(bytes.length);\n            for (let i = 0; i < bytes.length; i++) {\n                writer.write8(bytes[i]);\n            }\n        },\n        serialize: (value) => {\n            const bytes = toBytes(value);\n            const size = ulebEncode(bytes.length);\n            const result = new Uint8Array(size.length + bytes.length);\n            result.set(size, 0);\n            result.set(bytes, size.length);\n\n            return result;\n        },\n        validate: (value) => {\n            if (typeof value !== 'string') {\n                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n            }\n            options.validate?.(value);\n        },\n    });\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n    let lazyType: BcsType<T, Input> | null = null;\n    function getType() {\n        if (!lazyType) {\n            lazyType = cb();\n        }\n        return lazyType;\n    }\n\n    return new BcsType<T, Input>({\n        name: 'lazy' as never,\n        read: (data) => getType().read(data),\n        serializedSize: (value) => getType().serializedSize(value),\n        write: (value, writer) => getType().write(value, writer),\n        serialize: (value, options) => getType().serialize(value, options).toBytes(),\n    });\n}\n"],"names":["options"],"mappings":"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"}},
    {"offset": {"line": 693, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/utils/iota-types.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, splitGenericParameters } from '@iota/bcs';\n\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is string {\n    try {\n        const buffer = fromB58(value);\n        return buffer.length === TX_DIGEST_LENGTH;\n    } catch (e) {\n        return false;\n    }\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/iotaledger/iota/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/iota-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const IOTA_ADDRESS_LENGTH = 32;\nexport function isValidIotaAddress(value: string): value is string {\n    return isHex(value) && getHexByteLength(value) === IOTA_ADDRESS_LENGTH;\n}\n\nexport function isValidIotaObjectId(value: string): boolean {\n    return isValidIotaAddress(value);\n}\n\ntype StructTag = {\n    address: string;\n    module: string;\n    name: string;\n    typeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n    if (!type.includes('::')) return type;\n\n    return parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n    const [address, module] = type.split('::');\n\n    const rest = type.slice(address.length + module.length + 4);\n    const name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n    const typeParams = rest.includes('<')\n        ? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n              (typeParam) => parseTypeTag(typeParam.trim()),\n          )\n        : [];\n\n    return {\n        address: normalizeIotaAddress(address),\n        module,\n        name,\n        typeParams,\n    };\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n    const { address, module, name, typeParams } =\n        typeof type === 'string' ? parseStructTag(type) : type;\n\n    const formattedTypeParams =\n        typeParams?.length > 0\n            ? `<${typeParams\n                  .map((typeParam) =>\n                      typeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n                  )\n                  .join(',')}>`\n            : '';\n\n    return `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Normalize an IOTA address to ensure consistent format.\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `IOTA_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n * @param value The address to normalize\n * @param forceAdd0x Whether to add 0x prefix without removing any existing 0x prefixes\n * @param validate Whether to validate the return address\n * @returns The normalized address\n * @throws Error if flag `validate` enabled and the address contains invalid hex characters\n */\nexport function normalizeIotaAddress(\n    value: string,\n    forceAdd0x: boolean = false,\n    validate: boolean = false,\n): string {\n    let address = value.toLowerCase().replace(/ /g, '');\n    if (!forceAdd0x && address.startsWith('0x')) {\n        address = address.slice(2);\n    }\n    address = `0x${address.padStart(IOTA_ADDRESS_LENGTH * 2, '0')}`;\n    if (validate && !isValidIotaAddress(address)) {\n        throw new Error(`Invalid IOTA address: ${value}`);\n    } else {\n        return address;\n    }\n}\n\nexport function normalizeIotaObjectId(\n    value: string,\n    forceAdd0x: boolean = false,\n    validate: boolean = false,\n): string {\n    return normalizeIotaAddress(value, forceAdd0x, validate);\n}\n\nfunction isHex(value: string): boolean {\n    return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n    return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAIA,SAAS,SAAS,8BAA8B;;AAEhD,MAAM,mBAAmB;AAGlB,SAAS,yBAAyB,KAAA,EAAgC;IACrE,IAAI;QACA,MAAM,aAAS,2NAAA,EAAQ,KAAK;QAC5B,OAAO,OAAO,MAAA,KAAW;IAC7B,EAAA,OAAS,GAAG;QACR,OAAO;IACX;AACJ;AAQO,MAAM,sBAAsB;AAC5B,SAAS,mBAAmB,KAAA,EAAgC;IAC/D,OAAO,MAAM,KAAK,KAAK,iBAAiB,KAAK,MAAM;AACvD;AAEO,SAAS,oBAAoB,KAAA,EAAwB;IACxD,OAAO,mBAAmB,KAAK;AACnC;AASA,SAAS,aAAa,IAAA,EAAkC;IACpD,IAAI,CAAC,KAAK,QAAA,CAAS,IAAI,EAAG,CAAA,OAAO;IAEjC,OAAO,eAAe,IAAI;AAC9B;AAEO,SAAS,eAAe,IAAA,EAAyB;IACpD,MAAM,CAAC,SAAS,MAAM,CAAA,GAAI,KAAK,KAAA,CAAM,IAAI;IAEzC,MAAM,OAAO,KAAK,KAAA,CAAM,QAAQ,MAAA,GAAS,OAAO,MAAA,GAAS,CAAC;IAC1D,MAAM,OAAO,KAAK,QAAA,CAAS,GAAG,IAAI,KAAK,KAAA,CAAM,GAAG,KAAK,OAAA,CAAQ,GAAG,CAAC,IAAI;IACrE,MAAM,aAAa,KAAK,QAAA,CAAS,GAAG,QAC9B,4OAAA,EAAuB,KAAK,KAAA,CAAM,KAAK,OAAA,CAAQ,GAAG,IAAI,GAAG,KAAK,WAAA,CAAY,GAAG,CAAC,CAAC,EAAE,GAAA,CAC7E,CAAC,YAAc,aAAa,UAAU,IAAA,CAAK,CAAC,KAEhD,CAAC,CAAA;IAEP,OAAO;QACH,SAAS,qBAAqB,OAAO;QACrC;QACA;QACA;IACJ;AACJ;AAEO,SAAS,mBAAmB,IAAA,EAAkC;IACjE,MAAM,EAAE,OAAA,EAAS,MAAA,EAAQ,IAAA,EAAM,UAAA,CAAW,CAAA,GACtC,OAAO,SAAS,WAAW,eAAe,IAAI,IAAI;IAEtD,MAAM,sBACF,YAAY,SAAS,IACf,CAAA,CAAA,EAAI,WACC,GAAA,CAAI,CAAC,YACF,OAAO,cAAc,WAAW,YAAY,mBAAmB,SAAS,GAE3E,IAAA,CAAK,GAAG,CAAC,CAAA,CAAA,CAAA,GACd;IAEV,OAAO,GAAG,OAAO,CAAA,EAAA,EAAK,MAAM,CAAA,EAAA,EAAK,IAAI,GAAG,mBAAmB,EAAA;AAC/D;AAmBO,SAAS,qBACZ,KAAA,EACA,aAAsB,KAAA,EACtB,WAAoB,KAAA,EACd;IACN,IAAI,UAAU,MAAM,WAAA,CAAY,EAAE,OAAA,CAAQ,MAAM,EAAE;IAClD,IAAI,CAAC,cAAc,QAAQ,UAAA,CAAW,IAAI,GAAG;QACzC,UAAU,QAAQ,KAAA,CAAM,CAAC;IAC7B;IACA,UAAU,CAAA,EAAA,EAAK,QAAQ,QAAA,CAAS,sBAAsB,GAAG,GAAG,CAAC,EAAA;IAC7D,IAAI,YAAY,CAAC,mBAAmB,OAAO,GAAG;QAC1C,MAAM,IAAI,MAAM,CAAA,sBAAA,EAAyB,KAAK,EAAE;IACpD,OAAO;QACH,OAAO;IACX;AACJ;AAEO,SAAS,sBACZ,KAAA,EACA,aAAsB,KAAA,EACtB,WAAoB,KAAA,EACd;IACN,OAAO,qBAAqB,OAAO,YAAY,QAAQ;AAC3D;AAEA,SAAS,MAAM,KAAA,EAAwB;IACnC,OAAO,yBAAyB,IAAA,CAAK,KAAK,KAAK,MAAM,MAAA,GAAS,MAAM;AACxE;AAEA,SAAS,iBAAiB,KAAA,EAAuB;IAC7C,OAAO,WAAW,IAAA,CAAK,KAAK,IAAA,CAAK,MAAM,MAAA,GAAS,CAAA,IAAK,IAAI,MAAM,MAAA,GAAS;AAC5E"}},
    {"offset": {"line": 778, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/transactions/data/internal.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape, EnumOutputShape } from '@iota/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n    array,\n    boolean,\n    check,\n    integer,\n    lazy,\n    literal,\n    nullable,\n    nullish,\n    number,\n    object,\n    optional,\n    pipe,\n    record,\n    string,\n    transform,\n    tuple,\n    union,\n    unknown,\n} from 'valibot';\n\nimport { isValidIotaAddress, normalizeIotaAddress } from '../../utils/iota-types.js';\n\ntype Merge<T> = T extends object ? { [K in keyof T]: T[K] } : never;\n\ntype EnumSchema<T extends Record<string, GenericSchema<any>>> = GenericSchema<\n    EnumInputShape<\n        Merge<{\n            [K in keyof T]: InferInput<T[K]>;\n        }>\n    >,\n    EnumOutputShape<\n        Merge<{\n            [K in keyof T]: InferOutput<T[K]>;\n        }>\n    >\n>;\n\nexport function safeEnum<T extends Record<string, GenericSchema<any>>>(options: T): EnumSchema<T> {\n    const unionOptions = Object.entries(options).map(([key, value]) => object({ [key]: value }));\n\n    return pipe(\n        union(unionOptions),\n        transform((value) => ({\n            ...value,\n            $kind: Object.keys(value)[0] as keyof typeof value,\n        })),\n    ) as EnumSchema<T>;\n}\n\nexport const IotaAddress = pipe(\n    string(),\n    transform((value) => normalizeIotaAddress(value)),\n    check(isValidIotaAddress),\n);\nexport const ObjectID = IotaAddress;\nexport const BCSBytes = string();\nexport const JsonU64 = pipe(\n    union([string(), pipe(number(), integer())]),\n\n    check((val) => {\n        try {\n            BigInt(val);\n            return BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;\n        } catch {\n            return false;\n        }\n    }, 'Invalid u64'),\n);\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/base_types.rs#L138\n// Implemented as a tuple in rust\nexport const ObjectRef = object({\n    objectId: IotaAddress,\n    version: JsonU64,\n    digest: string(),\n});\nexport type ObjectRef = InferOutput<typeof ObjectRef>;\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L690-L702\nexport const Argument = pipe(\n    union([\n        object({ GasCoin: literal(true) }),\n        object({ Input: pipe(number(), integer()), type: optional(literal('pure')) }),\n        object({ Input: pipe(number(), integer()), type: optional(literal('object')) }),\n        object({ Result: pipe(number(), integer()) }),\n        object({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) }),\n    ]),\n    transform((value) => ({\n        ...value,\n        $kind: Object.keys(value)[0] as keyof typeof value,\n    })),\n    // Defined manually to add `type?: 'pure' | 'object'` to Input\n) as GenericSchema<\n    // Input\n    | { GasCoin: true }\n    | { Input: number; type?: 'pure' | 'object' }\n    | { Result: number }\n    | { NestedResult: [number, number] },\n    // Output\n    | { $kind: 'GasCoin'; GasCoin: true }\n    | { $kind: 'Input'; Input: number; type?: 'pure' }\n    | { $kind: 'Input'; Input: number; type?: 'object' }\n    | { $kind: 'Result'; Result: number }\n    | { $kind: 'NestedResult'; NestedResult: [number, number] }\n>;\n\nexport type Argument = InferOutput<typeof Argument>;\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L1387-L1392\nexport const GasData = object({\n    budget: nullable(JsonU64),\n    price: nullable(JsonU64),\n    owner: nullable(IotaAddress),\n    payment: nullable(array(ObjectRef)),\n});\nexport type GasData = InferOutput<typeof GasData>;\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag = object({\n    address: string(),\n    module: string(),\n    name: string(),\n    // type_params in rust, should be updated to use camelCase\n    typeParams: array(string()),\n});\nexport type StructTag = InferOutput<typeof StructTag>;\n\n// https://github.com/iotaledger/iota/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/iota-graphql-rpc/schema/current_progress_schema.graphql#L1614-L1627\nexport type OpenMoveTypeSignatureBody =\n    | 'address'\n    | 'bool'\n    | 'u8'\n    | 'u16'\n    | 'u32'\n    | 'u64'\n    | 'u128'\n    | 'u256'\n    | { vector: OpenMoveTypeSignatureBody }\n    | {\n          datatype: {\n              package: string;\n              module: string;\n              type: string;\n              typeParameters: OpenMoveTypeSignatureBody[];\n          };\n      }\n    | { typeParameter: number };\n\nexport const OpenMoveTypeSignatureBody: GenericSchema<OpenMoveTypeSignatureBody> = union([\n    literal('address'),\n    literal('bool'),\n    literal('u8'),\n    literal('u16'),\n    literal('u32'),\n    literal('u64'),\n    literal('u128'),\n    literal('u256'),\n    object({ vector: lazy(() => OpenMoveTypeSignatureBody) }),\n    object({\n        datatype: object({\n            package: string(),\n            module: string(),\n            type: string(),\n            typeParameters: array(lazy(() => OpenMoveTypeSignatureBody)),\n        }),\n    }),\n    object({ typeParameter: pipe(number(), integer()) }),\n]);\n\n// https://github.com/iotaledger/iota/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/iota-graphql-rpc/schema/current_progress_schema.graphql#L1609-L1612\nexport const OpenMoveTypeSignature = object({\n    ref: nullable(union([literal('&'), literal('&mut')])),\n    body: OpenMoveTypeSignatureBody,\n});\nexport type OpenMoveTypeSignature = InferOutput<typeof OpenMoveTypeSignature>;\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCall = object({\n    package: ObjectID,\n    module: string(),\n    function: string(),\n    // snake case in rust\n    typeArguments: array(string()),\n    arguments: array(Argument),\n    _argumentTypes: optional(nullable(array(OpenMoveTypeSignature))),\n});\nexport type ProgrammableMoveCall = InferOutput<typeof ProgrammableMoveCall>;\n\nexport const $Intent = object({\n    name: string(),\n    inputs: record(string(), union([Argument, array(Argument)])),\n    data: record(string(), unknown()),\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L657-L685\nexport const Command = safeEnum({\n    MoveCall: ProgrammableMoveCall,\n    TransferObjects: object({\n        objects: array(Argument),\n        address: Argument,\n    }),\n    SplitCoins: object({\n        coin: Argument,\n        amounts: array(Argument),\n    }),\n    MergeCoins: object({\n        destination: Argument,\n        sources: array(Argument),\n    }),\n    Publish: object({\n        modules: array(BCSBytes),\n        dependencies: array(ObjectID),\n    }),\n    MakeMoveVec: object({\n        type: nullable(string()),\n        elements: array(Argument),\n    }),\n    Upgrade: object({\n        modules: array(BCSBytes),\n        dependencies: array(ObjectID),\n        package: ObjectID,\n        ticket: Argument,\n    }),\n    $Intent,\n});\n\nexport type Command<Arg = Argument> = EnumOutputShape<{\n    MoveCall: {\n        package: string;\n        module: string;\n        function: string;\n        typeArguments: string[];\n        arguments: Arg[];\n        _argumentTypes?: OpenMoveTypeSignature[] | null;\n    };\n    TransferObjects: {\n        objects: Arg[];\n        address: Arg;\n    };\n    SplitCoins: {\n        coin: Arg;\n        amounts: Arg[];\n    };\n    MergeCoins: {\n        destination: Arg;\n        sources: Arg[];\n    };\n    Publish: {\n        modules: string[];\n        dependencies: string[];\n    };\n    MakeMoveVec: {\n        type: string | null;\n        elements: Arg[];\n    };\n    Upgrade: {\n        modules: string[];\n        dependencies: string[];\n        package: string;\n        ticket: Arg;\n    };\n    $Intent: {\n        name: string;\n        inputs: Record<string, Argument | Argument[]>;\n        data: Record<string, unknown>;\n    };\n}>;\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L102-L114\nexport const ObjectArg = safeEnum({\n    ImmOrOwnedObject: ObjectRef,\n    SharedObject: object({\n        objectId: ObjectID,\n        // snake case in rust\n        initialSharedVersion: JsonU64,\n        mutable: boolean(),\n    }),\n    Receiving: ObjectRef,\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L75-L80\nconst CallArg = safeEnum({\n    Object: ObjectArg,\n    Pure: object({\n        bytes: BCSBytes,\n    }),\n    UnresolvedPure: object({\n        value: unknown(),\n    }),\n    UnresolvedObject: object({\n        objectId: ObjectID,\n        version: optional(nullable(JsonU64)),\n        digest: optional(nullable(string())),\n        initialSharedVersion: optional(nullable(JsonU64)),\n    }),\n});\nexport type CallArg = InferOutput<typeof CallArg>;\n\nexport const NormalizedCallArg = safeEnum({\n    Object: ObjectArg,\n    Pure: object({\n        bytes: BCSBytes,\n    }),\n});\n\nexport const TransactionExpiration = safeEnum({\n    None: literal(true),\n    Epoch: JsonU64,\n});\n\nexport type TransactionExpiration = InferOutput<typeof TransactionExpiration>;\n\nexport const TransactionData = object({\n    version: literal(2),\n    sender: nullish(IotaAddress),\n    expiration: nullish(TransactionExpiration),\n    gasData: GasData,\n    inputs: array(CallArg),\n    commands: array(Command),\n});\nexport type TransactionData = InferOutput<typeof TransactionData>;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1011, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/transactions/Commands.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@iota/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { normalizeIotaObjectId } from '../utils/iota-types.js';\nimport { Argument } from './data/internal.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport type { Transaction } from './Transaction.js';\n\nexport type TransactionArgument =\n    | InferInput<typeof Argument>\n    | ((tx: Transaction) => InferInput<typeof Argument>);\nexport type TransactionInput = CallArg;\n\n// Keep in sync with constants in\n// crates/iota-framework/packages/iota-framework/sources/package.move\nexport enum UpgradePolicy {\n    COMPATIBLE = 0,\n    ADDITIVE = 128,\n    DEP_ONLY = 192,\n}\n\ntype TransactionShape<T extends Command['$kind']> = { $kind: T } & {\n    [K in T]: Extract<Command, { [K in T]: any }>[T];\n};\n\n/**\n * Simple helpers used to construct transactions:\n */\nexport const Commands = {\n    MoveCall(\n        input:\n            | {\n                  package: string;\n                  module: string;\n                  function: string;\n                  arguments?: Argument[];\n                  typeArguments?: string[];\n              }\n            | {\n                  target: string;\n                  arguments?: Argument[];\n                  typeArguments?: string[];\n              },\n    ): TransactionShape<'MoveCall'> {\n        const [pkg, mod = '', fn = ''] =\n            'target' in input\n                ? input.target.split('::')\n                : [input.package, input.module, input.function];\n\n        return {\n            $kind: 'MoveCall',\n            MoveCall: {\n                package: pkg,\n                module: mod,\n                function: fn,\n                typeArguments: input.typeArguments ?? [],\n                arguments: input.arguments ?? [],\n            },\n        };\n    },\n\n    TransferObjects(\n        objects: InferInput<typeof Argument>[],\n        address: InferInput<typeof Argument>,\n    ): TransactionShape<'TransferObjects'> {\n        return {\n            $kind: 'TransferObjects',\n            TransferObjects: {\n                objects: objects.map((o) => parse(Argument, o)),\n                address: parse(Argument, address),\n            },\n        };\n    },\n    SplitCoins(\n        coin: InferInput<typeof Argument>,\n        amounts: InferInput<typeof Argument>[],\n    ): TransactionShape<'SplitCoins'> {\n        return {\n            $kind: 'SplitCoins',\n            SplitCoins: {\n                coin: parse(Argument, coin),\n                amounts: amounts.map((o) => parse(Argument, o)),\n            },\n        };\n    },\n    MergeCoins(\n        destination: InferInput<typeof Argument>,\n        sources: InferInput<typeof Argument>[],\n    ): TransactionShape<'MergeCoins'> {\n        return {\n            $kind: 'MergeCoins',\n            MergeCoins: {\n                destination: parse(Argument, destination),\n                sources: sources.map((o) => parse(Argument, o)),\n            },\n        };\n    },\n    Publish({\n        modules,\n        dependencies,\n    }: {\n        modules: number[][] | string[];\n        dependencies: string[];\n    }): TransactionShape<'Publish'> {\n        return {\n            $kind: 'Publish',\n            Publish: {\n                modules: modules.map((module) =>\n                    typeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n                ),\n                dependencies: dependencies.map((dep) => normalizeIotaObjectId(dep)),\n            },\n        };\n    },\n    Upgrade({\n        modules,\n        dependencies,\n        package: packageId,\n        ticket,\n    }: {\n        modules: number[][] | string[];\n        dependencies: string[];\n        package: string;\n        ticket: InferInput<typeof Argument>;\n    }): TransactionShape<'Upgrade'> {\n        return {\n            $kind: 'Upgrade',\n            Upgrade: {\n                modules: modules.map((module) =>\n                    typeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n                ),\n                dependencies: dependencies.map((dep) => normalizeIotaObjectId(dep)),\n                package: packageId,\n                ticket: parse(Argument, ticket),\n            },\n        };\n    },\n    MakeMoveVec({\n        type,\n        elements,\n    }: {\n        type?: string;\n        elements: InferInput<typeof Argument>[];\n    }): TransactionShape<'MakeMoveVec'> {\n        return {\n            $kind: 'MakeMoveVec',\n            MakeMoveVec: {\n                type: type ?? null,\n                elements: elements.map((o) => parse(Argument, o)),\n            },\n        };\n    },\n    Intent({\n        name,\n        inputs = {},\n        data = {},\n    }: {\n        name: string;\n        inputs?: Record<string, InferInput<typeof Argument> | InferInput<typeof Argument>[]>;\n        data?: Record<string, unknown>;\n    }): TransactionShape<'$Intent'> {\n        return {\n            $kind: '$Intent',\n            $Intent: {\n                name,\n                inputs: Object.fromEntries(\n                    Object.entries(inputs).map(([key, value]) => [\n                        key,\n                        Array.isArray(value)\n                            ? value.map((o) => parse(Argument, o))\n                            : parse(Argument, value),\n                    ]),\n                ),\n                data,\n            },\n        };\n    },\n};\n"],"names":["UpgradePolicy"],"mappings":"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"}},
    {"offset": {"line": 1125, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/bcs/type-tag-serializer.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@iota/bcs';\n\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { TypeTag } from './types.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n    static parseFromStr(str: string, normalizeAddress = false): TypeTag {\n        if (str === 'address') {\n            return { address: null };\n        } else if (str === 'bool') {\n            return { bool: null };\n        } else if (str === 'u8') {\n            return { u8: null };\n        } else if (str === 'u16') {\n            return { u16: null };\n        } else if (str === 'u32') {\n            return { u32: null };\n        } else if (str === 'u64') {\n            return { u64: null };\n        } else if (str === 'u128') {\n            return { u128: null };\n        } else if (str === 'u256') {\n            return { u256: null };\n        } else if (str === 'signer') {\n            return { signer: null };\n        }\n\n        const vectorMatch = str.match(VECTOR_REGEX);\n        if (vectorMatch) {\n            return {\n                vector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n            };\n        }\n\n        const structMatch = str.match(STRUCT_REGEX);\n        if (structMatch) {\n            const address = normalizeAddress\n                ? normalizeIotaAddress(structMatch[1])\n                : structMatch[1];\n            return {\n                struct: {\n                    address,\n                    module: structMatch[2],\n                    name: structMatch[3],\n                    typeParams:\n                        structMatch[5] === undefined\n                            ? []\n                            : TypeTagSerializer.parseStructTypeArgs(\n                                  structMatch[5],\n                                  normalizeAddress,\n                              ),\n                },\n            };\n        }\n\n        throw new Error(`Encountered unexpected token when parsing type args for ${str}`);\n    }\n\n    static parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n        return splitGenericParameters(str).map((tok) =>\n            TypeTagSerializer.parseFromStr(tok, normalizeAddress),\n        );\n    }\n\n    static tagToString(tag: TypeTag): string {\n        if ('bool' in tag) {\n            return 'bool';\n        }\n        if ('u8' in tag) {\n            return 'u8';\n        }\n        if ('u16' in tag) {\n            return 'u16';\n        }\n        if ('u32' in tag) {\n            return 'u32';\n        }\n        if ('u64' in tag) {\n            return 'u64';\n        }\n        if ('u128' in tag) {\n            return 'u128';\n        }\n        if ('u256' in tag) {\n            return 'u256';\n        }\n        if ('address' in tag) {\n            return 'address';\n        }\n        if ('signer' in tag) {\n            return 'signer';\n        }\n        if ('vector' in tag) {\n            return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n        }\n        if ('struct' in tag) {\n            const struct = tag.struct;\n            const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n            return `${struct.address}::${struct.module}::${struct.name}${\n                typeParams ? `<${typeParams}>` : ''\n            }`;\n        }\n        throw new Error('Invalid TypeTag');\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1242, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/transactions/data/v1.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@iota/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n    array,\n    bigint,\n    boolean,\n    check,\n    integer,\n    is,\n    lazy,\n    literal,\n    nullable,\n    nullish,\n    number,\n    object,\n    optional,\n    parse,\n    pipe,\n    string,\n    union,\n    unknown,\n} from 'valibot';\n\nimport { TypeTagSerializer } from '../../bcs/index.js';\nimport type { StructTag as StructTagType, TypeTag as TypeTagType } from '../../bcs/types.js';\nimport { JsonU64, ObjectID, safeEnum, TransactionData } from './internal.js';\nimport type { Argument } from './internal.js';\n\nexport const ObjectRef = object({\n    digest: string(),\n    objectId: string(),\n    version: union([pipe(number(), integer()), string(), bigint()]),\n});\n\nconst ObjectArg = safeEnum({\n    ImmOrOwned: ObjectRef,\n    Shared: object({\n        objectId: ObjectID,\n        initialSharedVersion: JsonU64,\n        mutable: boolean(),\n    }),\n    Receiving: ObjectRef,\n});\n\nexport const NormalizedCallArg = safeEnum({\n    Object: ObjectArg,\n    Pure: array(pipe(number(), integer())),\n});\n\nconst TransactionInput = union([\n    object({\n        kind: literal('Input'),\n        index: pipe(number(), integer()),\n        value: unknown(),\n        type: optional(literal('object')),\n    }),\n    object({\n        kind: literal('Input'),\n        index: pipe(number(), integer()),\n        value: unknown(),\n        type: literal('pure'),\n    }),\n]);\n\nconst TransactionExpiration = union([\n    object({ Epoch: pipe(number(), integer()) }),\n    object({ None: nullable(literal(true)) }),\n]);\n\nconst StringEncodedBigint = pipe(\n    union([number(), string(), bigint()]),\n    check((val) => {\n        if (!['string', 'number', 'bigint'].includes(typeof val)) return false;\n\n        try {\n            BigInt(val as string);\n            return true;\n        } catch {\n            return false;\n        }\n    }),\n);\n\nexport const TypeTag: GenericSchema<TypeTagType> = union([\n    object({ bool: nullable(literal(true)) }),\n    object({ u8: nullable(literal(true)) }),\n    object({ u64: nullable(literal(true)) }),\n    object({ u128: nullable(literal(true)) }),\n    object({ address: nullable(literal(true)) }),\n    object({ signer: nullable(literal(true)) }),\n    object({ vector: lazy(() => TypeTag) }),\n    object({ struct: lazy(() => StructTag) }),\n    object({ u16: nullable(literal(true)) }),\n    object({ u32: nullable(literal(true)) }),\n    object({ u256: nullable(literal(true)) }),\n]);\n\n// https://github.com/iotaledger/iota/blob/cea8742e810142a8145fd83c4c142d61e561004a/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag: GenericSchema<StructTagType> = object({\n    address: string(),\n    module: string(),\n    name: string(),\n    typeParams: array(TypeTag),\n});\n\nconst GasConfig = object({\n    budget: optional(StringEncodedBigint),\n    price: optional(StringEncodedBigint),\n    payment: optional(array(ObjectRef)),\n    owner: optional(string()),\n});\n\nconst TransactionArgumentTypes = [\n    TransactionInput,\n    object({ kind: literal('GasCoin') }),\n    object({ kind: literal('Result'), index: pipe(number(), integer()) }),\n    object({\n        kind: literal('NestedResult'),\n        index: pipe(number(), integer()),\n        resultIndex: pipe(number(), integer()),\n    }),\n] as const;\n\n// Generic transaction argument\nexport const TransactionArgument = union([...TransactionArgumentTypes]);\n\nconst MoveCallTransaction = object({\n    kind: literal('MoveCall'),\n    target: pipe(\n        string(),\n        check((target) => target.split('::').length === 3),\n    ) as GenericSchema<`${string}::${string}::${string}`>,\n    typeArguments: array(string()),\n    arguments: array(TransactionArgument),\n});\n\nconst TransferObjectsTransaction = object({\n    kind: literal('TransferObjects'),\n    objects: array(TransactionArgument),\n    address: TransactionArgument,\n});\n\nconst SplitCoinsTransaction = object({\n    kind: literal('SplitCoins'),\n    coin: TransactionArgument,\n    amounts: array(TransactionArgument),\n});\n\nconst MergeCoinsTransaction = object({\n    kind: literal('MergeCoins'),\n    destination: TransactionArgument,\n    sources: array(TransactionArgument),\n});\n\nconst MakeMoveVecTransaction = object({\n    kind: literal('MakeMoveVec'),\n    type: union([object({ Some: TypeTag }), object({ None: nullable(literal(true)) })]),\n    objects: array(TransactionArgument),\n});\n\nconst PublishTransaction = object({\n    kind: literal('Publish'),\n    modules: array(array(pipe(number(), integer()))),\n    dependencies: array(string()),\n});\n\nconst UpgradeTransaction = object({\n    kind: literal('Upgrade'),\n    modules: array(array(pipe(number(), integer()))),\n    dependencies: array(string()),\n    packageId: string(),\n    ticket: TransactionArgument,\n});\n\nconst TransactionTypes = [\n    MoveCallTransaction,\n    TransferObjectsTransaction,\n    SplitCoinsTransaction,\n    MergeCoinsTransaction,\n    PublishTransaction,\n    UpgradeTransaction,\n    MakeMoveVecTransaction,\n] as const;\n\nconst TransactionType = union([...TransactionTypes]);\n\nexport const SerializedTransactionDataV1 = object({\n    version: literal(1),\n    sender: optional(string()),\n    expiration: nullish(TransactionExpiration),\n    gasConfig: GasConfig,\n    inputs: array(TransactionInput),\n    transactions: array(TransactionType),\n});\n\nexport type SerializedTransactionDataV1 = InferOutput<typeof SerializedTransactionDataV1>;\n\nexport function serializeV1TransactionData(\n    transactionData: TransactionData,\n): SerializedTransactionDataV1 {\n    const inputs: InferOutput<typeof TransactionInput>[] = transactionData.inputs.map(\n        (input, index) => {\n            if (input.Object) {\n                return {\n                    kind: 'Input',\n                    index,\n                    value: {\n                        Object: input.Object.ImmOrOwnedObject\n                            ? {\n                                  ImmOrOwned: input.Object.ImmOrOwnedObject,\n                              }\n                            : input.Object.Receiving\n                              ? {\n                                    Receiving: {\n                                        digest: input.Object.Receiving.digest,\n                                        version: input.Object.Receiving.version,\n                                        objectId: input.Object.Receiving.objectId,\n                                    },\n                                }\n                              : {\n                                    Shared: {\n                                        mutable: input.Object.SharedObject.mutable,\n                                        initialSharedVersion:\n                                            input.Object.SharedObject.initialSharedVersion,\n                                        objectId: input.Object.SharedObject.objectId,\n                                    },\n                                },\n                    },\n                    type: 'object',\n                };\n            }\n            if (input.Pure) {\n                return {\n                    kind: 'Input',\n                    index,\n                    value: {\n                        Pure: Array.from(fromBase64(input.Pure.bytes)),\n                    },\n                    type: 'pure',\n                };\n            }\n\n            if (input.UnresolvedPure) {\n                return {\n                    kind: 'Input',\n                    type: 'pure',\n                    index,\n                    value: input.UnresolvedPure.value,\n                };\n            }\n\n            if (input.UnresolvedObject) {\n                return {\n                    kind: 'Input',\n                    type: 'object',\n                    index,\n                    value: input.UnresolvedObject.objectId,\n                };\n            }\n\n            throw new Error('Invalid input');\n        },\n    );\n\n    return {\n        version: 1,\n        sender: transactionData.sender ?? undefined,\n        expiration:\n            transactionData.expiration?.$kind === 'Epoch'\n                ? { Epoch: Number(transactionData.expiration.Epoch) }\n                : transactionData.expiration\n                  ? { None: true }\n                  : null,\n        gasConfig: {\n            owner: transactionData.gasData.owner ?? undefined,\n            budget: transactionData.gasData.budget ?? undefined,\n            price: transactionData.gasData.price ?? undefined,\n            payment: transactionData.gasData.payment ?? undefined,\n        },\n        inputs,\n        transactions: transactionData.commands.map(\n            (command): InferOutput<typeof TransactionType> => {\n                if (command.MakeMoveVec) {\n                    return {\n                        kind: 'MakeMoveVec',\n                        type:\n                            command.MakeMoveVec.type === null\n                                ? { None: true }\n                                : {\n                                      Some: TypeTagSerializer.parseFromStr(\n                                          command.MakeMoveVec.type,\n                                      ),\n                                  },\n                        objects: command.MakeMoveVec.elements.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                    };\n                }\n                if (command.MergeCoins) {\n                    return {\n                        kind: 'MergeCoins',\n                        destination: convertTransactionArgument(\n                            command.MergeCoins.destination,\n                            inputs,\n                        ),\n                        sources: command.MergeCoins.sources.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                    };\n                }\n                if (command.MoveCall) {\n                    return {\n                        kind: 'MoveCall',\n                        target: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,\n                        typeArguments: command.MoveCall.typeArguments,\n                        arguments: command.MoveCall.arguments.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                    };\n                }\n                if (command.Publish) {\n                    return {\n                        kind: 'Publish',\n                        modules: command.Publish.modules.map((mod) => Array.from(fromBase64(mod))),\n                        dependencies: command.Publish.dependencies,\n                    };\n                }\n                if (command.SplitCoins) {\n                    return {\n                        kind: 'SplitCoins',\n                        coin: convertTransactionArgument(command.SplitCoins.coin, inputs),\n                        amounts: command.SplitCoins.amounts.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                    };\n                }\n                if (command.TransferObjects) {\n                    return {\n                        kind: 'TransferObjects',\n                        objects: command.TransferObjects.objects.map((arg) =>\n                            convertTransactionArgument(arg, inputs),\n                        ),\n                        address: convertTransactionArgument(\n                            command.TransferObjects.address,\n                            inputs,\n                        ),\n                    };\n                }\n\n                if (command.Upgrade) {\n                    return {\n                        kind: 'Upgrade',\n                        modules: command.Upgrade.modules.map((mod) => Array.from(fromBase64(mod))),\n                        dependencies: command.Upgrade.dependencies,\n                        packageId: command.Upgrade.package,\n                        ticket: convertTransactionArgument(command.Upgrade.ticket, inputs),\n                    };\n                }\n\n                throw new Error(`Unknown transaction ${Object.keys(command)}`);\n            },\n        ),\n    };\n}\n\nfunction convertTransactionArgument(\n    arg: Argument,\n    inputs: InferOutput<typeof TransactionInput>[],\n): InferOutput<typeof TransactionArgument> {\n    if (arg.$kind === 'GasCoin') {\n        return { kind: 'GasCoin' };\n    }\n    if (arg.$kind === 'Result') {\n        return { kind: 'Result', index: arg.Result };\n    }\n    if (arg.$kind === 'NestedResult') {\n        return {\n            kind: 'NestedResult',\n            index: arg.NestedResult[0],\n            resultIndex: arg.NestedResult[1],\n        };\n    }\n    if (arg.$kind === 'Input') {\n        return inputs[arg.Input];\n    }\n\n    throw new Error(`Invalid argument ${Object.keys(arg)}`);\n}\n\nexport function transactionDataFromV1(data: SerializedTransactionDataV1): TransactionData {\n    return parse(TransactionData, {\n        version: 2,\n        sender: data.sender ?? null,\n        expiration: data.expiration\n            ? 'Epoch' in data.expiration\n                ? { Epoch: data.expiration.Epoch }\n                : { None: true }\n            : null,\n        gasData: {\n            owner: data.gasConfig.owner ?? null,\n            budget: data.gasConfig.budget?.toString() ?? null,\n            price: data.gasConfig.price?.toString() ?? null,\n            payment:\n                data.gasConfig.payment?.map((ref) => ({\n                    digest: ref.digest,\n                    objectId: ref.objectId,\n                    version: ref.version.toString(),\n                })) ?? null,\n        },\n        inputs: data.inputs.map((input) => {\n            if (input.kind === 'Input') {\n                if (is(NormalizedCallArg, input.value)) {\n                    const value = parse(NormalizedCallArg, input.value);\n\n                    if (value.Object) {\n                        if (value.Object.ImmOrOwned) {\n                            return {\n                                Object: {\n                                    ImmOrOwnedObject: {\n                                        objectId: value.Object.ImmOrOwned.objectId,\n                                        version: String(value.Object.ImmOrOwned.version),\n                                        digest: value.Object.ImmOrOwned.digest,\n                                    },\n                                },\n                            };\n                        }\n                        if (value.Object.Shared) {\n                            return {\n                                Object: {\n                                    SharedObject: {\n                                        mutable: value.Object.Shared.mutable ?? null,\n                                        initialSharedVersion:\n                                            value.Object.Shared.initialSharedVersion,\n                                        objectId: value.Object.Shared.objectId,\n                                    },\n                                },\n                            };\n                        }\n                        if (value.Object.Receiving) {\n                            return {\n                                Object: {\n                                    Receiving: {\n                                        digest: value.Object.Receiving.digest,\n                                        version: String(value.Object.Receiving.version),\n                                        objectId: value.Object.Receiving.objectId,\n                                    },\n                                },\n                            };\n                        }\n\n                        throw new Error('Invalid object input');\n                    }\n\n                    return {\n                        Pure: {\n                            bytes: toBase64(new Uint8Array(value.Pure)),\n                        },\n                    };\n                }\n\n                if (input.type === 'object') {\n                    return {\n                        UnresolvedObject: {\n                            objectId: input.value as string,\n                        },\n                    };\n                }\n\n                return {\n                    UnresolvedPure: {\n                        value: input.value,\n                    },\n                };\n            }\n\n            throw new Error('Invalid input');\n        }),\n        commands: data.transactions.map((transaction) => {\n            switch (transaction.kind) {\n                case 'MakeMoveVec':\n                    return {\n                        MakeMoveVec: {\n                            type:\n                                'Some' in transaction.type\n                                    ? TypeTagSerializer.tagToString(transaction.type.Some)\n                                    : null,\n                            elements: transaction.objects.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                        },\n                    };\n                case 'MergeCoins': {\n                    return {\n                        MergeCoins: {\n                            destination: parseV1TransactionArgument(transaction.destination),\n                            sources: transaction.sources.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                        },\n                    };\n                }\n                case 'MoveCall': {\n                    const [pkg, mod, fn] = transaction.target.split('::');\n                    return {\n                        MoveCall: {\n                            package: pkg,\n                            module: mod,\n                            function: fn,\n                            typeArguments: transaction.typeArguments,\n                            arguments: transaction.arguments.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                        },\n                    };\n                }\n                case 'Publish': {\n                    return {\n                        Publish: {\n                            modules: transaction.modules.map((mod) =>\n                                toBase64(Uint8Array.from(mod)),\n                            ),\n                            dependencies: transaction.dependencies,\n                        },\n                    };\n                }\n                case 'SplitCoins': {\n                    return {\n                        SplitCoins: {\n                            coin: parseV1TransactionArgument(transaction.coin),\n                            amounts: transaction.amounts.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                        },\n                    };\n                }\n                case 'TransferObjects': {\n                    return {\n                        TransferObjects: {\n                            objects: transaction.objects.map((arg) =>\n                                parseV1TransactionArgument(arg),\n                            ),\n                            address: parseV1TransactionArgument(transaction.address),\n                        },\n                    };\n                }\n                case 'Upgrade': {\n                    return {\n                        Upgrade: {\n                            modules: transaction.modules.map((mod) =>\n                                toBase64(Uint8Array.from(mod)),\n                            ),\n                            dependencies: transaction.dependencies,\n                            package: transaction.packageId,\n                            ticket: parseV1TransactionArgument(transaction.ticket),\n                        },\n                    };\n                }\n            }\n\n            throw new Error(`Unknown transaction ${Object.keys(transaction)}`);\n        }),\n    } satisfies InferInput<typeof TransactionData>);\n}\n\nfunction parseV1TransactionArgument(\n    arg: InferOutput<typeof TransactionArgument>,\n): InferInput<typeof Argument> {\n    switch (arg.kind) {\n        case 'GasCoin': {\n            return { GasCoin: true };\n        }\n        case 'Result':\n            return { Result: arg.index };\n        case 'NestedResult': {\n            return { NestedResult: [arg.index, arg.resultIndex] };\n        }\n        case 'Input': {\n            return { Input: arg.index };\n        }\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1802, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/transactions/data/v2.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape } from '@iota/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n    array,\n    boolean,\n    integer,\n    literal,\n    nullable,\n    nullish,\n    number,\n    object,\n    optional,\n    pipe,\n    record,\n    string,\n    tuple,\n    union,\n    unknown,\n} from 'valibot';\n\nimport { BCSBytes, JsonU64, ObjectID, ObjectRef, IotaAddress } from './internal.js';\n\ntype Merge<T> = T extends object ? { [K in keyof T]: T[K] } : never;\n\nfunction enumUnion<T extends Record<string, GenericSchema<any>>>(options: T) {\n    return union(\n        Object.entries(options).map(([key, value]) => object({ [key]: value })),\n    ) as GenericSchema<\n        EnumInputShape<\n            Merge<{\n                [K in keyof T]: InferInput<T[K]>;\n            }>\n        >\n    >;\n}\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L690-L702\nconst Argument = enumUnion({\n    GasCoin: literal(true),\n    Input: pipe(number(), integer()),\n    Result: pipe(number(), integer()),\n    NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]),\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L1387-L1392\nconst GasData = object({\n    budget: nullable(JsonU64),\n    price: nullable(JsonU64),\n    owner: nullable(IotaAddress),\n    payment: nullable(array(ObjectRef)),\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCall = object({\n    package: ObjectID,\n    module: string(),\n    function: string(),\n    // snake case in rust\n    typeArguments: array(string()),\n    arguments: array(Argument),\n});\n\nconst $Intent = object({\n    name: string(),\n    inputs: record(string(), union([Argument, array(Argument)])),\n    data: record(string(), unknown()),\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L657-L685\nconst Command = enumUnion({\n    MoveCall: ProgrammableMoveCall,\n    TransferObjects: object({\n        objects: array(Argument),\n        address: Argument,\n    }),\n    SplitCoins: object({\n        coin: Argument,\n        amounts: array(Argument),\n    }),\n    MergeCoins: object({\n        destination: Argument,\n        sources: array(Argument),\n    }),\n    Publish: object({\n        modules: array(BCSBytes),\n        dependencies: array(ObjectID),\n    }),\n    MakeMoveVec: object({\n        type: nullable(string()),\n        elements: array(Argument),\n    }),\n    Upgrade: object({\n        modules: array(BCSBytes),\n        dependencies: array(ObjectID),\n        package: ObjectID,\n        ticket: Argument,\n    }),\n    $Intent,\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L102-L114\nconst ObjectArg = enumUnion({\n    ImmOrOwnedObject: ObjectRef,\n    SharedObject: object({\n        objectId: ObjectID,\n        // snake case in rust\n        initialSharedVersion: JsonU64,\n        mutable: boolean(),\n    }),\n    Receiving: ObjectRef,\n});\n\n// https://github.com/iotaledger/iota/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/iota-types/src/transaction.rs#L75-L80\nconst CallArg = enumUnion({\n    Object: ObjectArg,\n    Pure: object({\n        bytes: BCSBytes,\n    }),\n    UnresolvedPure: object({\n        value: unknown(),\n    }),\n    UnresolvedObject: object({\n        objectId: ObjectID,\n        version: optional(nullable(JsonU64)),\n        digest: optional(nullable(string())),\n        initialSharedVersion: optional(nullable(JsonU64)),\n    }),\n});\n\nconst TransactionExpiration = enumUnion({\n    None: literal(true),\n    Epoch: JsonU64,\n});\n\nexport const SerializedTransactionDataV2 = object({\n    version: literal(2),\n    sender: nullish(IotaAddress),\n    expiration: nullish(TransactionExpiration),\n    gasData: GasData,\n    inputs: array(CallArg),\n    commands: array(Command),\n});\n\nexport type SerializedTransactionDataV2 = InferOutput<typeof SerializedTransactionDataV2>;\n"],"names":[],"mappings":";;;;AAMA;AAkBA,SAAS,UAAU,SAAS,UAAU,WAAW,mBAAmB;;;AAIpE,SAAS,UAAwD,OAAA,EAAY;IACzE,WAAO,yMAAA,EACH,OAAO,OAAA,CAAQ,OAAO,EAAE,GAAA,CAAI,CAAC,CAAC,KAAK,KAAK,CAAA,OAAM,0MAAA,EAAO;YAAE,CAAC,GAAG,CAAA,EAAG;QAAM,CAAC,CAAC;AAQ9E;AAGA,MAAM,WAAW,UAAU;IACvB,aAAS,2MAAA,EAAQ,IAAI;IACrB,WAAO,wMAAA,MAAK,0MAAA,CAAO,QAAG,2MAAA,CAAQ,CAAC;IAC/B,YAAQ,wMAAA,MAAK,0MAAA,CAAO,QAAG,2MAAA,CAAQ,CAAC;IAChC,kBAAc,yMAAA,EAAM;YAAC,wMAAA,MAAK,0MAAA,CAAO,QAAG,2MAAA,CAAQ,CAAC;YAAG,wMAAA,MAAK,0MAAA,CAAO,QAAG,2MAAA,CAAQ,CAAC,CAAC;KAAC;AAC9E,CAAC;AAGD,MAAM,cAAU,0MAAA,EAAO;IACnB,YAAQ,4MAAA,EAAS,kSAAO;IACxB,WAAO,4MAAA,EAAS,kSAAO;IACvB,WAAO,4MAAA,EAAS,sSAAW;IAC3B,aAAS,4MAAA,MAAS,yMAAA,EAAM,oSAAS,CAAC;AACtC,CAAC;AAGD,MAAM,2BAAuB,0MAAA,EAAO;IAChC,SAAS,mSAAA;IACT,YAAQ,0MAAA,CAAO;IACf,cAAU,0MAAA,CAAO;IAAA,qBAAA;IAEjB,mBAAe,yMAAA,MAAM,0MAAA,CAAO,CAAC;IAC7B,eAAW,yMAAA,EAAM,QAAQ;AAC7B,CAAC;AAED,MAAM,cAAU,0MAAA,EAAO;IACnB,UAAM,0MAAA,CAAO;IACb,YAAQ,0MAAA,MAAO,0MAAA,CAAO,QAAG,yMAAA,EAAM;QAAC;YAAU,yMAAA,EAAM,QAAQ,CAAC;KAAC,CAAC;IAC3D,UAAM,0MAAA,MAAO,0MAAA,CAAO,QAAG,2MAAA,CAAQ,CAAC;AACpC,CAAC;AAGD,MAAM,UAAU,UAAU;IACtB,UAAU;IACV,qBAAiB,0MAAA,EAAO;QACpB,aAAS,yMAAA,EAAM,QAAQ;QACvB,SAAS;IACb,CAAC;IACD,gBAAY,0MAAA,EAAO;QACf,MAAM;QACN,aAAS,yMAAA,EAAM,QAAQ;IAC3B,CAAC;IACD,gBAAY,0MAAA,EAAO;QACf,aAAa;QACb,aAAS,yMAAA,EAAM,QAAQ;IAC3B,CAAC;IACD,aAAS,0MAAA,EAAO;QACZ,aAAS,yMAAA,EAAM,mSAAQ;QACvB,kBAAc,yMAAA,EAAM,mSAAQ;IAChC,CAAC;IACD,iBAAa,0MAAA,EAAO;QAChB,UAAM,4MAAA,MAAS,0MAAA,CAAO,CAAC;QACvB,cAAU,yMAAA,EAAM,QAAQ;IAC5B,CAAC;IACD,aAAS,0MAAA,EAAO;QACZ,aAAS,yMAAA,EAAM,mSAAQ;QACvB,kBAAc,yMAAA,EAAM,mSAAQ;QAC5B,SAAS,mSAAA;QACT,QAAQ;IACZ,CAAC;IACD;AACJ,CAAC;AAGD,MAAM,YAAY,UAAU;IACxB,kBAAkB,oSAAA;IAClB,kBAAc,0MAAA,EAAO;QACjB,UAAU,mSAAA;QAAA,qBAAA;QAEV,sBAAsB,kSAAA;QACtB,aAAS,2MAAA,CAAQ;IACrB,CAAC;IACD,WAAW,oSAAA;AACf,CAAC;AAGD,MAAM,UAAU,UAAU;IACtB,QAAQ;IACR,UAAM,0MAAA,EAAO;QACT,OAAO,mSAAA;IACX,CAAC;IACD,oBAAgB,0MAAA,EAAO;QACnB,WAAO,2MAAA,CAAQ;IACnB,CAAC;IACD,sBAAkB,0MAAA,EAAO;QACrB,UAAU,mSAAA;QACV,aAAS,4MAAA,MAAS,4MAAA,EAAS,kSAAO,CAAC;QACnC,YAAQ,4MAAA,MAAS,4MAAA,MAAS,0MAAA,CAAO,CAAC,CAAC;QACnC,0BAAsB,4MAAA,MAAS,4MAAA,EAAS,kSAAO,CAAC;IACpD,CAAC;AACL,CAAC;AAED,MAAM,wBAAwB,UAAU;IACpC,UAAM,2MAAA,EAAQ,IAAI;IAClB,OAAO,kSAAA;AACX,CAAC;AAEM,MAAM,kCAA8B,0MAAA,EAAO;IAC9C,aAAS,2MAAA,EAAQ,CAAC;IAClB,YAAQ,2MAAA,EAAQ,sSAAW;IAC3B,gBAAY,2MAAA,EAAQ,qBAAqB;IACzC,SAAS;IACT,YAAQ,yMAAA,EAAM,OAAO;IACrB,cAAU,yMAAA,EAAM,OAAO;AAC3B,CAAC"}},
    {"offset": {"line": 1919, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/transactions/Inputs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@iota/bcs';\nimport type { SerializedBcs } from '@iota/bcs';\n\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { CallArg, ObjectRef } from './data/internal.js';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction Pure(data: Uint8Array | SerializedBcs<any>): Extract<CallArg, { Pure: unknown }> {\n    return {\n        $kind: 'Pure',\n        Pure: {\n            bytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64(),\n        },\n    };\n}\n\nexport const Inputs = {\n    Pure,\n    ObjectRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n        return {\n            $kind: 'Object',\n            Object: {\n                $kind: 'ImmOrOwnedObject',\n                ImmOrOwnedObject: {\n                    digest,\n                    version,\n                    objectId: normalizeIotaAddress(objectId),\n                },\n            },\n        };\n    },\n    SharedObjectRef({\n        objectId,\n        mutable,\n        initialSharedVersion,\n    }: {\n        objectId: string;\n        mutable: boolean;\n        initialSharedVersion: number | string;\n    }): Extract<CallArg, { Object: unknown }> {\n        return {\n            $kind: 'Object',\n            Object: {\n                $kind: 'SharedObject',\n                SharedObject: {\n                    mutable,\n                    initialSharedVersion,\n                    objectId: normalizeIotaAddress(objectId),\n                },\n            },\n        };\n    },\n    ReceivingRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n        return {\n            $kind: 'Object',\n            Object: {\n                $kind: 'Receiving',\n                Receiving: {\n                    digest,\n                    version,\n                    objectId: normalizeIotaAddress(objectId),\n                },\n            },\n        };\n    },\n};\n"],"names":[],"mappings":";;;;AAIA,SAAS,gBAAgB;AAGzB,SAAS,4BAA4B;;;AAIrC,SAAS,KAAK,IAAA,EAA4E;IACtF,OAAO;QACH,OAAO;QACP,MAAM;YACF,OAAO,gBAAgB,iBAAa,4NAAA,EAAS,IAAI,IAAI,KAAK,QAAA,CAAS;QACvE;IACJ;AACJ;AAEO,MAAM,SAAS;IAClB;IACA,WAAU,EAAE,QAAA,EAAU,MAAA,EAAQ,OAAA,CAAQ,CAAA,EAAqD;QACvF,OAAO;YACH,OAAO;YACP,QAAQ;gBACJ,OAAO;gBACP,kBAAkB;oBACd;oBACA;oBACA,cAAU,qSAAA,EAAqB,QAAQ;gBAC3C;YACJ;QACJ;IACJ;IACA,iBAAgB,EACZ,QAAA,EACA,OAAA,EACA,oBAAA,EACJ,EAI0C;QACtC,OAAO;YACH,OAAO;YACP,QAAQ;gBACJ,OAAO;gBACP,cAAc;oBACV;oBACA;oBACA,cAAU,qSAAA,EAAqB,QAAQ;gBAC3C;YACJ;QACJ;IACJ;IACA,cAAa,EAAE,QAAA,EAAU,MAAA,EAAQ,OAAA,CAAQ,CAAA,EAAqD;QAC1F,OAAO;YACH,OAAO;YACP,QAAQ;gBACJ,OAAO;gBACP,WAAW;oBACP;oBACA;oBACA,cAAU,qSAAA,EAAqB,QAAQ;gBAC3C;YACJ;QACJ;IACJ;AACJ"}},
    {"offset": {"line": 1983, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Bbcs%401.4.0/node_modules/%40iota/bcs/src/bcs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n    BcsType,\n    bigUIntBcsType,\n    dynamicSizeBcsType,\n    fixedSizeBcsType,\n    lazyBcsType,\n    stringLikeBcsType,\n    uIntBcsType,\n} from './bcs-type.js';\nimport type { EnumInputShape, EnumOutputShape } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n    /**\n     * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n     * @example\n     * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n     */\n    u8(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u8',\n            readMethod: 'read8',\n            writeMethod: 'write8',\n            size: 1,\n            maxValue: 2 ** 8 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n     * @example\n     * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n     */\n    u16(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u16',\n            readMethod: 'read16',\n            writeMethod: 'write16',\n            size: 2,\n            maxValue: 2 ** 16 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n     * @example\n     * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n     */\n    u32(options?: BcsTypeOptions<number>) {\n        return uIntBcsType({\n            name: 'u32',\n            readMethod: 'read32',\n            writeMethod: 'write32',\n            size: 4,\n            maxValue: 2 ** 32 - 1,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n     * @example\n     * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n     */\n    u64(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u64',\n            readMethod: 'read64',\n            writeMethod: 'write64',\n            size: 8,\n            maxValue: 2n ** 64n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n     * @example\n     * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n     */\n    u128(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u128',\n            readMethod: 'read128',\n            writeMethod: 'write128',\n            size: 16,\n            maxValue: 2n ** 128n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n     * @example\n     * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n     */\n    u256(options?: BcsTypeOptions<string, number | bigint | string>) {\n        return bigUIntBcsType({\n            name: 'u256',\n            readMethod: 'read256',\n            writeMethod: 'write256',\n            size: 32,\n            maxValue: 2n ** 256n - 1n,\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write boolean values.\n     * @example\n     * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n     */\n    bool(options?: BcsTypeOptions<boolean>) {\n        return fixedSizeBcsType<boolean>({\n            name: 'bool',\n            size: 1,\n            read: (reader) => reader.read8() === 1,\n            write: (value, writer) => writer.write8(value ? 1 : 0),\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'boolean') {\n                    throw new TypeError(`Expected boolean, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n     * @example\n     *\n     */\n    uleb128(options?: BcsTypeOptions<number>) {\n        return dynamicSizeBcsType<number>({\n            name: 'uleb128',\n            read: (reader) => reader.readULEB(),\n            serialize: (value) => {\n                return Uint8Array.from(ulebEncode(value));\n            },\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a fixed length byte array\n     * @param size The number of bytes this types represents\n     * @example\n     * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n     */\n    bytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n        return fixedSizeBcsType<Uint8Array>({\n            name: `bytes[${size}]`,\n            size,\n            read: (reader) => reader.readBytes(size),\n            write: (value, writer) => {\n                for (let i = 0; i < size; i++) {\n                    writer.write8(value[i] ?? 0);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== size) {\n                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a variable length byte array\n     *\n     * @example\n     * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n     */\n    byteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n        return new BcsType<Uint8Array, Iterable<number>>({\n            name: `bytesVector`,\n            read: (reader) => {\n                const length = reader.readULEB();\n\n                return reader.readBytes(length);\n            },\n            write: (value, writer) => {\n                const array = new Uint8Array(value);\n                writer.writeULEB(array.length);\n                for (let i = 0; i < array.length; i++) {\n                    writer.write8(array[i] ?? 0);\n                }\n            },\n            ...options,\n            serializedSize: (value) => {\n                const length = 'length' in value ? (value.length as number) : null;\n                return length == null ? null : ulebEncode(length).length + length;\n            },\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n     * @example\n     * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n     */\n    string(options?: BcsTypeOptions<string>) {\n        return stringLikeBcsType({\n            name: 'string',\n            toBytes: (value) => new TextEncoder().encode(value),\n            fromBytes: (bytes) => new TextDecoder().decode(bytes),\n            ...options,\n        });\n    },\n\n    /**\n     * Creates a BcsType that represents a fixed length array of a given type\n     * @param size The number of elements in the array\n     * @param type The BcsType of each element in the array\n     * @example\n     * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n     */\n    fixedArray<T, Input>(\n        size: number,\n        type: BcsType<T, Input>,\n        options?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n    ) {\n        return new BcsType<T[], Iterable<Input> & { length: number }>({\n            name: `${type.name}[${size}]`,\n            read: (reader) => {\n                const result: T[] = new Array(size);\n                for (let i = 0; i < size; i++) {\n                    result[i] = type.read(reader);\n                }\n                return result;\n            },\n            write: (value, writer) => {\n                for (const item of value) {\n                    type.write(item, writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== size) {\n                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing an optional value\n     * @param type The BcsType of the optional value\n     * @example\n     * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n     * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n     */\n    option<T, Input>(type: BcsType<T, Input>) {\n        return bcs\n            .enum(`Option<${type.name}>`, {\n                None: null,\n                Some: type,\n            })\n            .transform({\n                input: (value: Input | null | undefined) => {\n                    if (value == null) {\n                        return { None: true };\n                    }\n\n                    return { Some: value };\n                },\n                output: (value) => {\n                    if (value.$kind === 'Some') {\n                        return value.Some;\n                    }\n\n                    return null;\n                },\n            });\n    },\n\n    /**\n     * Creates a BcsType representing a variable length vector of a given type\n     * @param type The BcsType of each element in the vector\n     *\n     * @example\n     * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n     */\n    vector<T, Input>(\n        type: BcsType<T, Input>,\n        options?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n    ) {\n        return new BcsType<T[], Iterable<Input> & { length: number }>({\n            name: `vector<${type.name}>`,\n            read: (reader) => {\n                const length = reader.readULEB();\n                const result: T[] = new Array(length);\n                for (let i = 0; i < length; i++) {\n                    result[i] = type.read(reader);\n                }\n                return result;\n            },\n            write: (value, writer) => {\n                writer.writeULEB(value.length);\n                for (const item of value) {\n                    type.write(item, writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!value || typeof value !== 'object' || !('length' in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a tuple of a given set of types\n     * @param types The BcsTypes for each element in the tuple\n     *\n     * @example\n     * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n     * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n     */\n    tuple<const Types extends readonly BcsType<any>[]>(\n        types: Types,\n        options?: BcsTypeOptions<\n            {\n                -readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n            },\n            {\n                [K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n            }\n        >,\n    ) {\n        return new BcsType<\n            {\n                -readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n            },\n            {\n                [K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n            }\n        >({\n            name: `(${types.map((t) => t.name).join(', ')})`,\n            serializedSize: (values) => {\n                let total = 0;\n                for (let i = 0; i < types.length; i++) {\n                    const size = types[i].serializedSize(values[i]);\n                    if (size == null) {\n                        return null;\n                    }\n\n                    total += size;\n                }\n\n                return total;\n            },\n            read: (reader) => {\n                const result: unknown[] = [];\n                for (const type of types) {\n                    result.push(type.read(reader));\n                }\n                return result as never;\n            },\n            write: (value, writer) => {\n                for (let i = 0; i < types.length; i++) {\n                    types[i].write(value[i], writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (!Array.isArray(value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== types.length) {\n                    throw new TypeError(\n                        `Expected array of length ${types.length}, found ${value.length}`,\n                    );\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a struct of a given set of fields\n     * @param name The name of the struct\n     * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n     *\n     * @example\n     * const struct = bcs.struct('MyStruct', {\n     *  a: bcs.u8(),\n     *  b: bcs.string(),\n     * })\n     * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n     */\n    struct<T extends Record<string, BcsType<any>>>(\n        name: string,\n        fields: T,\n        options?: Omit<\n            BcsTypeOptions<\n                {\n                    [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n                },\n                {\n                    [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n                }\n            >,\n            'name'\n        >,\n    ) {\n        const canonicalOrder = Object.entries(fields);\n\n        return new BcsType<\n            {\n                [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n            },\n            {\n                [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n            }\n        >({\n            name,\n            serializedSize: (values) => {\n                let total = 0;\n                for (const [field, type] of canonicalOrder) {\n                    const size = type.serializedSize(values[field]);\n                    if (size == null) {\n                        return null;\n                    }\n\n                    total += size;\n                }\n\n                return total;\n            },\n            read: (reader) => {\n                const result: Record<string, unknown> = {};\n                for (const [field, type] of canonicalOrder) {\n                    result[field] = type.read(reader);\n                }\n\n                return result as never;\n            },\n            write: (value, writer) => {\n                for (const [field, type] of canonicalOrder) {\n                    type.write(value[field], writer);\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'object' || value == null) {\n                    throw new TypeError(`Expected object, found ${typeof value}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing an enum of a given set of options\n     * @param name The name of the enum\n     * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n     * null can be used to represent a variant with no data.\n     *\n     * @example\n     * const enum = bcs.enum('MyEnum', {\n     *   A: bcs.u8(),\n     *   B: bcs.string(),\n     *   C: null,\n     * })\n     * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n     * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n     * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n     */\n    enum<T extends Record<string, BcsType<any> | null>>(\n        name: string,\n        values: T,\n        options?: Omit<\n            BcsTypeOptions<\n                EnumOutputShape<{\n                    [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n                }>,\n                EnumInputShape<{\n                    [K in keyof T]: T[K] extends BcsType<any, infer U>\n                        ? U\n                        : boolean | object | null;\n                }>\n            >,\n            'name'\n        >,\n    ) {\n        const canonicalOrder = Object.entries(values as object);\n        return new BcsType<\n            EnumOutputShape<{\n                [K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n            }>,\n            EnumInputShape<{\n                [K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n            }>\n        >({\n            name,\n            read: (reader) => {\n                const index = reader.readULEB();\n\n                const enumEntry = canonicalOrder[index];\n                if (!enumEntry) {\n                    throw new TypeError(`Unknown value ${index} for enum ${name}`);\n                }\n\n                const [kind, type] = enumEntry;\n\n                return {\n                    [kind]: type?.read(reader) ?? true,\n                    $kind: kind,\n                } as never;\n            },\n            write: (value, writer) => {\n                const [name, val] = Object.entries(value).filter(([name]) =>\n                    Object.hasOwn(values, name),\n                )[0];\n\n                for (let i = 0; i < canonicalOrder.length; i++) {\n                    const [optionName, optionType] = canonicalOrder[i];\n                    if (optionName === name) {\n                        writer.writeULEB(i);\n                        optionType?.write(val, writer);\n                        return;\n                    }\n                }\n            },\n            ...options,\n            validate: (value) => {\n                options?.validate?.(value);\n                if (typeof value !== 'object' || value == null) {\n                    throw new TypeError(`Expected object, found ${typeof value}`);\n                }\n\n                const keys = Object.keys(value).filter(\n                    (k) => value[k] !== undefined && Object.hasOwn(values, k),\n                );\n\n                if (keys.length !== 1) {\n                    throw new TypeError(\n                        `Expected object with one key, but found ${keys.length} for type ${name}}`,\n                    );\n                }\n\n                const [variant] = keys;\n\n                if (!Object.hasOwn(values, variant)) {\n                    throw new TypeError(`Invalid enum variant ${variant}`);\n                }\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType representing a map of a given key and value type\n     * @param keyType The BcsType of the key\n     * @param valueType The BcsType of the value\n     * @example\n     * const map = bcs.map(bcs.u8(), bcs.string())\n     * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n     */\n    map<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n        return bcs.vector(bcs.tuple([keyType, valueType])).transform({\n            name: `Map<${keyType.name}, ${valueType.name}>`,\n            input: (value: Map<InputK, InputV>) => {\n                return [...value.entries()];\n            },\n            output: (value) => {\n                const result = new Map<K, V>();\n                for (const [key, val] of value) {\n                    result.set(key, val);\n                }\n                return result;\n            },\n        });\n    },\n\n    /**\n     * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n     * @param cb A callback that returns the BcsType\n     */\n    lazy<T extends BcsType<any>>(cb: () => T): T {\n        return lazyBcsType(cb) as T;\n    },\n};\n"],"names":["name"],"mappings":"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"}},
    {"offset": {"line": 2465, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/bcs/bcs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@iota/bcs';\nimport { bcs, fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@iota/bcs';\n\nimport {\n    isValidIotaAddress,\n    normalizeIotaAddress,\n    IOTA_ADDRESS_LENGTH,\n} from '../utils/iota-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\nimport type { TypeTag as TypeTagType } from './types.js';\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n    return bcs\n        .u64({\n            name: 'unsafe_u64',\n            ...(options as object),\n        })\n        .transform({\n            input: (val: number | string) => val,\n            output: (val) => Number(val),\n        });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n    return bcs.enum('Option', {\n        None: null,\n        Some: type,\n    });\n}\n\nexport const Address = bcs.bytes(IOTA_ADDRESS_LENGTH).transform({\n    validate: (val) => {\n        const address = typeof val === 'string' ? val : toHex(val);\n        if (!address || !isValidIotaAddress(normalizeIotaAddress(address))) {\n            throw new Error(`Invalid IOTA address ${address}`);\n        }\n    },\n    input: (val: string | Uint8Array) =>\n        typeof val === 'string' ? fromHex(normalizeIotaAddress(val)) : val,\n    output: (val) => normalizeIotaAddress(toHex(val)),\n});\n\nexport const ObjectDigest = bcs.vector(bcs.u8()).transform({\n    name: 'ObjectDigest',\n    input: (value: string) => fromBase58(value),\n    output: (value) => toBase58(new Uint8Array(value)),\n    validate: (value) => {\n        if (fromBase58(value).length !== 32) {\n            throw new Error('ObjectDigest must be 32 bytes');\n        }\n    },\n});\n\nexport const IotaObjectRef = bcs.struct('IotaObjectRef', {\n    objectId: Address,\n    version: bcs.u64(),\n    digest: ObjectDigest,\n});\n\nexport const SharedObjectRef = bcs.struct('SharedObjectRef', {\n    objectId: Address,\n    initialSharedVersion: bcs.u64(),\n    mutable: bcs.bool(),\n});\n\nexport const ObjectArg = bcs.enum('ObjectArg', {\n    ImmOrOwnedObject: IotaObjectRef,\n    SharedObject: SharedObjectRef,\n    Receiving: IotaObjectRef,\n});\n\nexport const Owner = bcs.enum('Owner', {\n    AddressOwner: Address,\n    ObjectOwner: Address,\n    Shared: bcs.struct('Shared', {\n        initialSharedVersion: bcs.u64(),\n    }),\n    Immutable: null,\n});\n\nexport const CallArg = bcs.enum('CallArg', {\n    Pure: bcs.struct('Pure', {\n        bytes: bcs.vector(bcs.u8()).transform({\n            input: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n            output: (val) => toBase64(new Uint8Array(val)),\n        }),\n    }),\n    Object: ObjectArg,\n});\n\nconst InnerTypeTag: BcsType<TypeTagType, TypeTagType> = bcs.enum('TypeTag', {\n    bool: null,\n    u8: null,\n    u64: null,\n    u128: null,\n    address: null,\n    signer: null,\n    vector: bcs.lazy(() => InnerTypeTag),\n    struct: bcs.lazy(() => StructTag),\n    u16: null,\n    u32: null,\n    u256: null,\n}) as BcsType<TypeTagType>;\n\nexport const TypeTag = InnerTypeTag.transform({\n    input: (typeTag: string | TypeTagType) =>\n        typeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n    output: (typeTag: TypeTagType) => TypeTagSerializer.tagToString(typeTag),\n});\n\nexport const Argument = bcs.enum('Argument', {\n    GasCoin: null,\n    Input: bcs.u16(),\n    Result: bcs.u16(),\n    NestedResult: bcs.tuple([bcs.u16(), bcs.u16()]),\n});\n\nexport const ProgrammableMoveCall = bcs.struct('ProgrammableMoveCall', {\n    package: Address,\n    module: bcs.string(),\n    function: bcs.string(),\n    typeArguments: bcs.vector(TypeTag),\n    arguments: bcs.vector(Argument),\n});\n\nexport const Command = bcs.enum('Command', {\n    /**\n     * A Move Call - any public Move function can be called via\n     * this transaction. The results can be used that instant to pass\n     * into the next transaction.\n     */\n    MoveCall: ProgrammableMoveCall,\n    /**\n     * Transfer vector of objects to a receiver.\n     */\n    TransferObjects: bcs.struct('TransferObjects', {\n        objects: bcs.vector(Argument),\n        address: Argument,\n    }),\n    // /**\n    //  * Split `amount` from a `coin`.\n    //  */\n    SplitCoins: bcs.struct('SplitCoins', {\n        coin: Argument,\n        amounts: bcs.vector(Argument),\n    }),\n    // /**\n    //  * Merge Vector of Coins (`sources`) into a `destination`.\n    //  */\n    MergeCoins: bcs.struct('MergeCoins', {\n        destination: Argument,\n        sources: bcs.vector(Argument),\n    }),\n    // /**\n    //  * Publish a Move module.\n    //  */\n    Publish: bcs.struct('Publish', {\n        modules: bcs.vector(\n            bcs.vector(bcs.u8()).transform({\n                input: (val: string | Uint8Array) =>\n                    typeof val === 'string' ? fromBase64(val) : val,\n                output: (val) => toBase64(new Uint8Array(val)),\n            }),\n        ),\n        dependencies: bcs.vector(Address),\n    }),\n    // /**\n    //  * Build a vector of objects using the input arguments.\n    //  * It is impossible to export construct a `vector<T: key>` otherwise,\n    //  * so this call serves a utility function.\n    //  */\n    MakeMoveVec: bcs.struct('MakeMoveVec', {\n        type: optionEnum(TypeTag).transform({\n            input: (val: string | null) =>\n                val === null\n                    ? {\n                          None: true,\n                      }\n                    : {\n                          Some: val,\n                      },\n            output: (val) => val.Some ?? null,\n        }),\n        elements: bcs.vector(Argument),\n    }),\n    Upgrade: bcs.struct('Upgrade', {\n        modules: bcs.vector(\n            bcs.vector(bcs.u8()).transform({\n                input: (val: string | Uint8Array) =>\n                    typeof val === 'string' ? fromBase64(val) : val,\n                output: (val) => toBase64(new Uint8Array(val)),\n            }),\n        ),\n        dependencies: bcs.vector(Address),\n        package: Address,\n        ticket: Argument,\n    }),\n});\n\nexport const ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n    inputs: bcs.vector(CallArg),\n    commands: bcs.vector(Command),\n});\n\nexport const TransactionKind = bcs.enum('TransactionKind', {\n    ProgrammableTransaction: ProgrammableTransaction,\n    ChangeEpoch: null,\n    Genesis: null,\n    ConsensusCommitPrologue: null,\n});\n\nexport const TransactionExpiration = bcs.enum('TransactionExpiration', {\n    None: null,\n    Epoch: unsafe_u64(),\n});\n\nexport const StructTag = bcs.struct('StructTag', {\n    address: Address,\n    module: bcs.string(),\n    name: bcs.string(),\n    typeParams: bcs.vector(InnerTypeTag),\n});\n\nexport const GasData = bcs.struct('GasData', {\n    payment: bcs.vector(IotaObjectRef),\n    owner: Address,\n    price: bcs.u64(),\n    budget: bcs.u64(),\n});\n\nexport const TransactionDataV1 = bcs.struct('TransactionDataV1', {\n    kind: TransactionKind,\n    sender: Address,\n    gasData: GasData,\n    expiration: TransactionExpiration,\n});\n\nexport const TransactionData = bcs.enum('TransactionData', {\n    V1: TransactionDataV1,\n});\n\nexport const IntentScope = bcs.enum('IntentScope', {\n    TransactionData: null,\n    TransactionEffects: null,\n    CheckpointSummary: null,\n    PersonalMessage: null,\n});\n\nexport const IntentVersion = bcs.enum('IntentVersion', {\n    V0: null,\n});\n\nexport const AppId = bcs.enum('AppId', {\n    Iota: null,\n});\n\nexport const Intent = bcs.struct('Intent', {\n    scope: IntentScope,\n    version: IntentVersion,\n    appId: AppId,\n});\n\nexport function IntentMessage<T extends BcsType<any>>(T: T) {\n    return bcs.struct(`IntentMessage<${T.name}>`, {\n        intent: Intent,\n        value: T,\n    });\n}\n\nexport const CompressedSignature = bcs.enum('CompressedSignature', {\n    ED25519: bcs.fixedArray(64, bcs.u8()),\n    Secp256k1: bcs.fixedArray(64, bcs.u8()),\n    Secp256r1: bcs.fixedArray(64, bcs.u8()),\n});\n\nexport const PublicKey = bcs.enum('PublicKey', {\n    ED25519: bcs.fixedArray(32, bcs.u8()),\n    Secp256k1: bcs.fixedArray(33, bcs.u8()),\n    Secp256r1: bcs.fixedArray(33, bcs.u8()),\n});\n\nexport const MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n    pubKey: PublicKey,\n    weight: bcs.u8(),\n});\n\nexport const MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n    pk_map: bcs.vector(MultiSigPkMap),\n    threshold: bcs.u16(),\n});\n\nexport const MultiSig = bcs.struct('MultiSig', {\n    sigs: bcs.vector(CompressedSignature),\n    bitmap: bcs.u16(),\n    multisig_pk: MultiSigPublicKey,\n});\n\nexport const base64String = bcs.vector(bcs.u8()).transform({\n    input: (val: string | Uint8Array) => (typeof val === 'string' ? fromBase64(val) : val),\n    output: (val) => toBase64(new Uint8Array(val)),\n});\n\nexport const SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n    intentMessage: IntentMessage(TransactionData),\n    txSignatures: bcs.vector(base64String),\n});\n\nexport const SenderSignedData = bcs.vector(SenderSignedTransaction, {\n    name: 'SenderSignedData',\n});\n\nexport const PasskeyAuthenticator = bcs.struct('PasskeyAuthenticator', {\n    authenticatorData: bcs.vector(bcs.u8()),\n    clientDataJson: bcs.string(),\n    userSignature: bcs.vector(bcs.u8()),\n});\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2805, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/bcs/effects.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@iota/bcs';\n\nimport { Address, ObjectDigest, Owner } from './bcs.js';\n\nconst PackageUpgradeError = bcs.enum('PackageUpgradeError', {\n    UnableToFetchPackage: bcs.struct('UnableToFetchPackage', { packageId: Address }),\n    NotAPackage: bcs.struct('NotAPackage', { objectId: Address }),\n    IncompatibleUpgrade: null,\n    DigestDoesNotMatch: bcs.struct('DigestDoesNotMatch', { digest: bcs.vector(bcs.u8()) }),\n    UnknownUpgradePolicy: bcs.struct('UnknownUpgradePolicy', { policy: bcs.u8() }),\n    PackageIDDoesNotMatch: bcs.struct('PackageIDDoesNotMatch', {\n        packageId: Address,\n        ticketId: Address,\n    }),\n});\n\nconst ModuleId = bcs.struct('ModuleId', {\n    address: Address,\n    name: bcs.string(),\n});\nconst MoveLocation = bcs.struct('MoveLocation', {\n    module: ModuleId,\n    function: bcs.u16(),\n    instruction: bcs.u16(),\n    functionName: bcs.option(bcs.string()),\n});\n\nconst CommandArgumentError = bcs.enum('CommandArgumentError', {\n    TypeMismatch: null,\n    InvalidBCSBytes: null,\n    InvalidUsageOfPureArg: null,\n    InvalidArgumentToPrivateEntryFunction: null,\n    IndexOutOfBounds: bcs.struct('IndexOutOfBounds', { idx: bcs.u16() }),\n    SecondaryIndexOutOfBounds: bcs.struct('SecondaryIndexOutOfBounds', {\n        resultIdx: bcs.u16(),\n        secondaryIdx: bcs.u16(),\n    }),\n    InvalidResultArity: bcs.struct('InvalidResultArity', { resultIdx: bcs.u16() }),\n    InvalidGasCoinUsage: null,\n    InvalidValueUsage: null,\n    InvalidObjectByValue: null,\n    InvalidObjectByMutRef: null,\n    SharedObjectOperationNotAllowed: null,\n});\n\nconst TypeArgumentError = bcs.enum('TypeArgumentError', {\n    TypeNotFound: null,\n    ConstraintNotSatisfied: null,\n});\n\nconst ExecutionFailureStatus = bcs.enum('ExecutionFailureStatus', {\n    InsufficientGas: null,\n    InvalidGasObject: null,\n    InvariantViolation: null,\n    FeatureNotYetSupported: null,\n    MoveObjectTooBig: bcs.struct('MoveObjectTooBig', {\n        objectSize: bcs.u64(),\n        maxObjectSize: bcs.u64(),\n    }),\n    MovePackageTooBig: bcs.struct('MovePackageTooBig', {\n        objectSize: bcs.u64(),\n        maxObjectSize: bcs.u64(),\n    }),\n    CircularObjectOwnership: bcs.struct('CircularObjectOwnership', { object: Address }),\n    InsufficientCoinBalance: null,\n    CoinBalanceOverflow: null,\n    PublishErrorNonZeroAddress: null,\n    IotaMoveVerificationError: null,\n    MovePrimitiveRuntimeError: bcs.option(MoveLocation),\n    MoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),\n    VMVerificationOrDeserializationError: null,\n    VMInvariantViolation: null,\n    FunctionNotFound: null,\n    ArityMismatch: null,\n    TypeArityMismatch: null,\n    NonEntryFunctionInvoked: null,\n    CommandArgumentError: bcs.struct('CommandArgumentError', {\n        argIdx: bcs.u16(),\n        kind: CommandArgumentError,\n    }),\n    TypeArgumentError: bcs.struct('TypeArgumentError', {\n        argumentIdx: bcs.u16(),\n        kind: TypeArgumentError,\n    }),\n    UnusedValueWithoutDrop: bcs.struct('UnusedValueWithoutDrop', {\n        resultIdx: bcs.u16(),\n        secondaryIdx: bcs.u16(),\n    }),\n    InvalidPublicFunctionReturnType: bcs.struct('InvalidPublicFunctionReturnType', {\n        idx: bcs.u16(),\n    }),\n    InvalidTransferObject: null,\n    EffectsTooLarge: bcs.struct('EffectsTooLarge', { currentSize: bcs.u64(), maxSize: bcs.u64() }),\n    PublishUpgradeMissingDependency: null,\n    PublishUpgradeDependencyDowngrade: null,\n    PackageUpgradeError: bcs.struct('PackageUpgradeError', { upgradeError: PackageUpgradeError }),\n    WrittenObjectsTooLarge: bcs.struct('WrittenObjectsTooLarge', {\n        currentSize: bcs.u64(),\n        maxSize: bcs.u64(),\n    }),\n    CertificateDenied: null,\n    IotaMoveVerificationTimedout: null,\n    SharedObjectOperationNotAllowed: null,\n    InputObjectDeleted: null,\n    ExecutionCancelledDueToSharedObjectCongestion: bcs.struct(\n        'ExecutionCancelledDueToSharedObjectCongestion',\n        {\n            congestedObjects: bcs.vector(Address),\n        },\n    ),\n    AddressDeniedForCoin: bcs.struct('AddressDeniedForCoin', {\n        address: Address,\n        coinType: bcs.string(),\n    }),\n    CoinTypeGlobalPause: bcs.struct('CoinTypeGlobalPause', { coinType: bcs.string() }),\n    ExecutionCancelledDueToRandomnessUnavailable: null,\n});\n\nconst ExecutionStatus = bcs.enum('ExecutionStatus', {\n    Success: null,\n    Failed: bcs.struct('ExecutionFailed', {\n        error: ExecutionFailureStatus,\n        command: bcs.option(bcs.u64()),\n    }),\n});\n\nconst GasCostSummary = bcs.struct('GasCostSummary', {\n    computationCost: bcs.u64(),\n    computationCostBurned: bcs.u64(),\n    storageCost: bcs.u64(),\n    storageRebate: bcs.u64(),\n    nonRefundableStorageFee: bcs.u64(),\n});\n\nconst VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);\n\nconst ObjectIn = bcs.enum('ObjectIn', {\n    NotExist: null,\n    Exist: bcs.tuple([VersionDigest, Owner]),\n});\n\nexport const ObjectOut = bcs.enum('ObjectOut', {\n    NotExist: null,\n    ObjectWrite: bcs.tuple([ObjectDigest, Owner]),\n    PackageWrite: VersionDigest,\n});\n\nconst IDOperation = bcs.enum('IDOperation', {\n    None: null,\n    Created: null,\n    Deleted: null,\n});\n\nconst EffectsObjectChange = bcs.struct('EffectsObjectChange', {\n    inputState: ObjectIn,\n    outputState: ObjectOut,\n    idOperation: IDOperation,\n});\n\nconst UnchangedSharedKind = bcs.enum('UnchangedSharedKind', {\n    ReadOnlyRoot: VersionDigest,\n    MutateDeleted: bcs.u64(),\n    ReadDeleted: bcs.u64(),\n    Cancelled: bcs.u64(),\n    PerEpochConfig: null,\n});\n\nconst TransactionEffectsV1 = bcs.struct('TransactionEffectsV1', {\n    status: ExecutionStatus,\n    executedEpoch: bcs.u64(),\n    gasUsed: GasCostSummary,\n    transactionDigest: ObjectDigest,\n    gasObjectIndex: bcs.option(bcs.u32()),\n    eventsDigest: bcs.option(ObjectDigest),\n    dependencies: bcs.vector(ObjectDigest),\n    lamportVersion: bcs.u64(),\n    changedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),\n    unchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),\n    auxDataDigest: bcs.option(ObjectDigest),\n});\n\nexport const TransactionEffects = bcs.enum('TransactionEffects', {\n    V1: TransactionEffectsV1,\n});\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3023, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/bcs/index.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@iota/bcs';\n\nimport {\n    Address,\n    AppId,\n    Argument,\n    CallArg,\n    Command,\n    CompressedSignature,\n    GasData,\n    Intent,\n    IntentMessage,\n    IntentScope,\n    IntentVersion,\n    MultiSig,\n    MultiSigPkMap,\n    MultiSigPublicKey,\n    ObjectArg,\n    ObjectDigest,\n    Owner,\n    ProgrammableMoveCall,\n    ProgrammableTransaction,\n    PublicKey,\n    SenderSignedData,\n    SenderSignedTransaction,\n    SharedObjectRef,\n    StructTag,\n    IotaObjectRef,\n    TransactionData,\n    TransactionDataV1,\n    TransactionExpiration,\n    TransactionKind,\n    TypeTag,\n    PasskeyAuthenticator,\n} from './bcs.js';\nimport { TransactionEffects } from './effects.js';\n\nexport type { TypeTag } from './types.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\nexport { BcsType, type BcsTypeOptions } from '@iota/bcs';\n\nconst iotaBcs = {\n    ...bcs,\n    U8: bcs.u8(),\n    U16: bcs.u16(),\n    U32: bcs.u32(),\n    U64: bcs.u64(),\n    U128: bcs.u128(),\n    U256: bcs.u256(),\n    ULEB128: bcs.uleb128(),\n    Bool: bcs.bool(),\n    String: bcs.string(),\n    Address,\n    AppId,\n    Argument,\n    CallArg,\n    CompressedSignature,\n    GasData,\n    Intent,\n    IntentMessage,\n    IntentScope,\n    IntentVersion,\n    MultiSig,\n    MultiSigPkMap,\n    MultiSigPublicKey,\n    ObjectArg,\n    ObjectDigest,\n    Owner,\n    ProgrammableMoveCall,\n    ProgrammableTransaction,\n    PublicKey,\n    SenderSignedData,\n    SenderSignedTransaction,\n    SharedObjectRef,\n    StructTag,\n    IotaObjectRef,\n    Command,\n    TransactionData,\n    TransactionDataV1,\n    TransactionExpiration,\n    TransactionKind,\n    TypeTag,\n    TransactionEffects,\n    PasskeyAuthenticator,\n};\n\nexport { iotaBcs as bcs };\n"],"names":[],"mappings":";;;;AAIA,SAAS,WAAW;AAEpB;AAiCA,SAAS,0BAA0B;AAInC,SAAS,yBAAyB;AAClC,SAAS,eAAoC;;;;;;AAE7C,MAAM,UAAU;IACZ,GAAG,uNAAA;IACH,IAAI,uNAAA,CAAI,EAAA,CAAG;IACX,KAAK,uNAAA,CAAI,GAAA,CAAI;IACb,KAAK,uNAAA,CAAI,GAAA,CAAI;IACb,KAAK,uNAAA,CAAI,GAAA,CAAI;IACb,MAAM,uNAAA,CAAI,IAAA,CAAK;IACf,MAAM,uNAAA,CAAI,IAAA,CAAK;IACf,SAAS,uNAAA,CAAI,OAAA,CAAQ;IACrB,MAAM,uNAAA,CAAI,IAAA,CAAK;IACf,QAAQ,uNAAA,CAAI,MAAA,CAAO;aACnB,4QAAA;WACA,0QAAA;cACA,6QAAA;aACA,4QAAA;yBACA,wRAAA;aACA,4QAAA;YACA,2QAAA;mBACA,kRAAA;iBACA,gRAAA;mBACA,kRAAA;cACA,6QAAA;mBACA,kRAAA;uBACA,sRAAA;eACA,8QAAA;kBACA,iRAAA;WACA,0QAAA;0BACA,yRAAA;6BACA,4RAAA;eACA,8QAAA;sBACA,qRAAA;6BACA,4RAAA;qBACA,oRAAA;eACA,8QAAA;mBACA,kRAAA;aACA,4QAAA;qBACA,oRAAA;uBACA,sRAAA;2BACA,0RAAA;qBACA,oRAAA;aACA,4QAAA;wBACA,2RAAA;0BACA,yRAAA;AACJ"}},
    {"offset": {"line": 3087, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/utils/constants.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { normalizeIotaObjectId } from './iota-types.js';\n\nexport const IOTA_DECIMALS = 9;\nexport const NANOS_PER_IOTA = BigInt(1000000000);\n\nexport const MOVE_STDLIB_ADDRESS = '0x1';\nexport const IOTA_FRAMEWORK_ADDRESS = '0x2';\nexport const IOTA_SYSTEM_ADDRESS = '0x3';\nexport const IOTA_CLOCK_OBJECT_ID = normalizeIotaObjectId('0x6');\nexport const IOTA_SYSTEM_MODULE_NAME = 'iota_system';\nexport const IOTA_TYPE_ARG = `${IOTA_FRAMEWORK_ADDRESS}::iota::IOTA`;\nexport const IOTA_SYSTEM_STATE_OBJECT_ID: string = normalizeIotaObjectId('0x5');\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAIA,SAAS,6BAA6B;;AAE/B,MAAM,gBAAgB;AACtB,MAAM,iBAAiB,OAAO,GAAU;AAExC,MAAM,sBAAsB;AAC5B,MAAM,yBAAyB;AAC/B,MAAM,sBAAsB;AAC5B,MAAM,2BAAuB,sSAAA,EAAsB,KAAK;AACxD,MAAM,0BAA0B;AAChC,MAAM,gBAAgB,GAAG,sBAAsB,CAAA,YAAA,CAAA;AAC/C,MAAM,kCAAsC,sSAAA,EAAsB,KAAK"}},
    {"offset": {"line": 3124, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/transactions/serializer.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType } from '@iota/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { IotaMoveNormalizedType } from '../client/index.js';\nimport { MOVE_STDLIB_ADDRESS, IOTA_FRAMEWORK_ADDRESS } from '../utils/index.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { OpenMoveTypeSignature, OpenMoveTypeSignatureBody } from './data/internal.js';\n\nconst OBJECT_MODULE_NAME = 'object';\nconst ID_STRUCT_NAME = 'ID';\n\nconst STD_ASCII_MODULE_NAME = 'ascii';\nconst STD_ASCII_STRUCT_NAME = 'String';\n\nconst STD_UTF8_MODULE_NAME = 'string';\nconst STD_UTF8_STRUCT_NAME = 'String';\n\nconst STD_OPTION_MODULE_NAME = 'option';\nconst STD_OPTION_STRUCT_NAME = 'Option';\n\nexport function isTxContext(param: OpenMoveTypeSignature): boolean {\n    const struct =\n        typeof param.body === 'object' && 'datatype' in param.body ? param.body.datatype : null;\n\n    return (\n        !!struct &&\n        normalizeIotaAddress(struct.package) === normalizeIotaAddress('0x2') &&\n        struct.module === 'tx_context' &&\n        struct.type === 'TxContext'\n    );\n}\n\nexport function getPureBcsSchema(typeSignature: OpenMoveTypeSignatureBody): BcsType<any> | null {\n    if (typeof typeSignature === 'string') {\n        switch (typeSignature) {\n            case 'address':\n                return bcs.Address;\n            case 'bool':\n                return bcs.Bool;\n            case 'u8':\n                return bcs.U8;\n            case 'u16':\n                return bcs.U16;\n            case 'u32':\n                return bcs.U32;\n            case 'u64':\n                return bcs.U64;\n            case 'u128':\n                return bcs.U128;\n            case 'u256':\n                return bcs.U256;\n            default:\n                throw new Error(`Unknown type signature ${typeSignature}`);\n        }\n    }\n\n    if ('vector' in typeSignature) {\n        if (typeSignature.vector === 'u8') {\n            return bcs.vector(bcs.U8).transform({\n                input: (val: string | Uint8Array) =>\n                    typeof val === 'string' ? new TextEncoder().encode(val) : val,\n                output: (val) => val,\n            });\n        }\n        const type = getPureBcsSchema(typeSignature.vector);\n        return type ? bcs.vector(type) : null;\n    }\n\n    if ('datatype' in typeSignature) {\n        const pkg = normalizeIotaAddress(typeSignature.datatype.package);\n\n        if (pkg === normalizeIotaAddress(MOVE_STDLIB_ADDRESS)) {\n            if (\n                typeSignature.datatype.module === STD_ASCII_MODULE_NAME &&\n                typeSignature.datatype.type === STD_ASCII_STRUCT_NAME\n            ) {\n                return bcs.String;\n            }\n\n            if (\n                typeSignature.datatype.module === STD_UTF8_MODULE_NAME &&\n                typeSignature.datatype.type === STD_UTF8_STRUCT_NAME\n            ) {\n                return bcs.String;\n            }\n\n            if (\n                typeSignature.datatype.module === STD_OPTION_MODULE_NAME &&\n                typeSignature.datatype.type === STD_OPTION_STRUCT_NAME\n            ) {\n                const type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);\n                return type ? bcs.vector(type) : null;\n            }\n        }\n\n        if (\n            pkg === normalizeIotaAddress(IOTA_FRAMEWORK_ADDRESS) &&\n            typeSignature.datatype.module === OBJECT_MODULE_NAME &&\n            typeSignature.datatype.type === ID_STRUCT_NAME\n        ) {\n            return bcs.Address;\n        }\n    }\n\n    return null;\n}\n\nexport function normalizedTypeToMoveTypeSignature(\n    type: IotaMoveNormalizedType,\n): OpenMoveTypeSignature {\n    if (typeof type === 'object' && 'Reference' in type) {\n        return {\n            ref: '&',\n            body: normalizedTypeToMoveTypeSignatureBody(type.Reference),\n        };\n    }\n    if (typeof type === 'object' && 'MutableReference' in type) {\n        return {\n            ref: '&mut',\n            body: normalizedTypeToMoveTypeSignatureBody(type.MutableReference),\n        };\n    }\n\n    return {\n        ref: null,\n        body: normalizedTypeToMoveTypeSignatureBody(type),\n    };\n}\n\nfunction normalizedTypeToMoveTypeSignatureBody(\n    type: IotaMoveNormalizedType,\n): OpenMoveTypeSignatureBody {\n    if (typeof type === 'string') {\n        switch (type) {\n            case 'Address':\n                return 'address';\n            case 'Bool':\n                return 'bool';\n            case 'U8':\n                return 'u8';\n            case 'U16':\n                return 'u16';\n            case 'U32':\n                return 'u32';\n            case 'U64':\n                return 'u64';\n            case 'U128':\n                return 'u128';\n            case 'U256':\n                return 'u256';\n            default:\n                throw new Error(`Unexpected type ${type}`);\n        }\n    }\n\n    if ('Vector' in type) {\n        return { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };\n    }\n\n    if ('Struct' in type) {\n        return {\n            datatype: {\n                package: type.Struct.address,\n                module: type.Struct.module,\n                type: type.Struct.name,\n                typeParameters: type.Struct.typeArguments.map(\n                    normalizedTypeToMoveTypeSignatureBody,\n                ),\n            },\n        };\n    }\n\n    if ('TypeParameter' in type) {\n        return { typeParameter: type.TypeParameter };\n    }\n\n    throw new Error(`Unexpected type ${JSON.stringify(type)}`);\n}\n\nexport function pureBcsSchemaFromOpenMoveTypeSignatureBody(\n    typeSignature: OpenMoveTypeSignatureBody,\n): BcsType<any> {\n    if (typeof typeSignature === 'string') {\n        switch (typeSignature) {\n            case 'address':\n                return bcs.Address;\n            case 'bool':\n                return bcs.Bool;\n            case 'u8':\n                return bcs.U8;\n            case 'u16':\n                return bcs.U16;\n            case 'u32':\n                return bcs.U32;\n            case 'u64':\n                return bcs.U64;\n            case 'u128':\n                return bcs.U128;\n            case 'u256':\n                return bcs.U256;\n            default:\n                throw new Error(`Unknown type signature ${typeSignature}`);\n        }\n    }\n\n    if ('vector' in typeSignature) {\n        return bcs.vector(pureBcsSchemaFromOpenMoveTypeSignatureBody(typeSignature.vector));\n    }\n\n    throw new Error(`Expected pure typeSignature, but got ${JSON.stringify(typeSignature)}`);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3302, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/transactions/json-rpc-resolver.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parse } from 'valibot';\n\nimport type { BcsType } from '../bcs/index.js';\nimport { bcs } from '../bcs/index.js';\nimport type { IotaClient } from '../client/client.js';\nimport { normalizeIotaAddress, normalizeIotaObjectId, IOTA_TYPE_ARG } from '../utils/index.js';\nimport { ObjectRef } from './data/internal.js';\nimport type { Argument, CallArg, Command, OpenMoveTypeSignature } from './data/internal.js';\nimport { Inputs } from './Inputs.js';\nimport { getPureBcsSchema, isTxContext, normalizedTypeToMoveTypeSignature } from './serializer.js';\nimport type { TransactionDataBuilder } from './TransactionData.js';\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 50_000_000_000;\n\nexport interface BuildTransactionOptions {\n    client?: IotaClient;\n    onlyTransactionKind?: boolean;\n    maxSizeBytes?: number;\n}\n\nexport interface SerializeTransactionOptions extends BuildTransactionOptions {\n    supportedIntents?: string[];\n}\n\nexport type TransactionPlugin = (\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n    next: () => Promise<void>,\n) => Promise<void>;\n\nexport async function resolveTransactionData(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n    next: () => Promise<void>,\n) {\n    await normalizeInputs(transactionData, options);\n    await resolveObjectReferences(transactionData, options);\n\n    if (!options.onlyTransactionKind) {\n        await setGasPrice(transactionData, options);\n        await setGasBudget(transactionData, options);\n        await setGasPayment(transactionData, options);\n    }\n    await validate(transactionData);\n    return await next();\n}\n\nasync function setGasPrice(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    if (!transactionData.gasConfig.price) {\n        transactionData.gasConfig.price = String(await getClient(options).getReferenceGasPrice());\n    }\n}\n\nasync function setGasBudget(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    if (transactionData.gasConfig.budget) {\n        return;\n    }\n\n    const dryRunResult = await getClient(options).dryRunTransactionBlock({\n        transactionBlock: transactionData.build({\n            overrides: {\n                gasData: {\n                    budget: String(MAX_GAS),\n                    payment: [],\n                },\n            },\n        }),\n    });\n\n    if (dryRunResult.effects.status.status !== 'success') {\n        throw new Error(\n            `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n            { cause: dryRunResult },\n        );\n    }\n\n    const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n\n    const baseComputationCostWithOverhead =\n        BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n    const gasBudget =\n        baseComputationCostWithOverhead +\n        BigInt(dryRunResult.effects.gasUsed.storageCost) -\n        BigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n    transactionData.gasConfig.budget = String(\n        gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n    );\n}\n\n// The current default is just picking _all_ coins we can which may not be ideal.\nasync function setGasPayment(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    if (!transactionData.gasConfig.payment) {\n        const coins = await getClient(options).getCoins({\n            owner: transactionData.gasConfig.owner || transactionData.sender!,\n            coinType: IOTA_TYPE_ARG,\n        });\n\n        const paymentCoins = coins.data\n            // Filter out coins that are also used as input:\n            .filter((coin) => {\n                const matchingInput = transactionData.inputs.find((input) => {\n                    if (input.Object?.ImmOrOwnedObject) {\n                        return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n                    }\n\n                    return false;\n                });\n\n                return !matchingInput;\n            })\n            .map((coin) => ({\n                objectId: coin.coinObjectId,\n                digest: coin.digest,\n                version: coin.version,\n            }));\n\n        if (!paymentCoins.length) {\n            throw new Error('No valid gas coins found for the transaction.');\n        }\n\n        transactionData.gasConfig.payment = paymentCoins.map((payment) =>\n            parse(ObjectRef, payment),\n        );\n    }\n}\n\nasync function resolveObjectReferences(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    // Keep track of the object references that will need to be resolved at the end of the transaction.\n    // We keep the input by-reference to avoid needing to re-resolve it:\n    const objectsToResolve = transactionData.inputs.filter((input) => {\n        return (\n            input.UnresolvedObject &&\n            !(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion)\n        );\n    }) as Extract<CallArg, { UnresolvedObject: unknown }>[];\n\n    const dedupedIds = [\n        ...new Set(\n            objectsToResolve.map((input) => normalizeIotaObjectId(input.UnresolvedObject.objectId)),\n        ),\n    ];\n\n    const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n\n    const resolvedObjects = new Map();\n    const erroredObjects = new Map();\n\n    await Promise.all(\n        objectChunks.map(async (chunk) => {\n            const chunkObjects = await getClient(options).multiGetObjects({\n                ids: chunk,\n                options: { showOwner: true },\n            });\n\n            for (const object of chunkObjects) {\n                const objectId = object.data?.objectId;\n                if (objectId) {\n                    if (object.error || !object.data) {\n                        erroredObjects.set(objectId, object.error);\n                        return;\n                    }\n                    const owner = object.data.owner;\n                    const initialSharedVersion =\n                        owner && typeof owner === 'object' && 'Shared' in owner\n                            ? owner.Shared.initial_shared_version\n                            : null;\n\n                    resolvedObjects.set(objectId, {\n                        objectId,\n                        digest: object.data.digest,\n                        version: object.data.version,\n                        initialSharedVersion,\n                    });\n                }\n            }\n        }),\n    );\n\n    if (erroredObjects.size > 0) {\n        throw new Error(\n            `The following input objects are invalid: ${Array.from(erroredObjects).join(', ')}`,\n        );\n    }\n\n    for (const [index, input] of transactionData.inputs.entries()) {\n        if (!input.UnresolvedObject) {\n            continue;\n        }\n\n        let updated: CallArg | undefined;\n        const id = normalizeIotaAddress(input.UnresolvedObject.objectId);\n        const object = resolvedObjects.get(id);\n\n        if (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n            updated = Inputs.SharedObjectRef({\n                objectId: id,\n                initialSharedVersion:\n                    input.UnresolvedObject.initialSharedVersion ||\n                    (object?.initialSharedVersion as string),\n                mutable: isUsedAsMutable(transactionData, index),\n            });\n        } else if (isUsedAsReceiving(transactionData, index)) {\n            updated = Inputs.ReceivingRef(\n                {\n                    objectId: id,\n                    digest: input.UnresolvedObject.digest ?? (object?.digest as string),\n                    version: input.UnresolvedObject.version ?? (object?.version as string),\n                }!,\n            );\n        }\n\n        transactionData.inputs[transactionData.inputs.indexOf(input)] =\n            updated ??\n            Inputs.ObjectRef({\n                objectId: id,\n                digest: input.UnresolvedObject.digest ?? (object?.digest as string),\n                version: input.UnresolvedObject.version ?? (object?.version as string),\n            });\n    }\n}\n\nasync function normalizeInputs(\n    transactionData: TransactionDataBuilder,\n    options: BuildTransactionOptions,\n) {\n    const { inputs, commands } = transactionData;\n    const moveCallsToResolve: Extract<Command, { MoveCall: unknown }>['MoveCall'][] = [];\n    const moveFunctionsToResolve = new Set<string>();\n\n    commands.forEach((command) => {\n        // Special case move call:\n        if (command.MoveCall) {\n            // Determine if any of the arguments require encoding.\n            // - If they don't, then this is good to go.\n            // - If they do, then we need to fetch the normalized move module.\n\n            // If we already know the argument types, we don't need to resolve them again\n            if (command.MoveCall._argumentTypes) {\n                return;\n            }\n\n            const inputs = command.MoveCall.arguments.map((arg) => {\n                if (arg.$kind === 'Input') {\n                    return transactionData.inputs[arg.Input];\n                }\n                return null;\n            });\n            const needsResolution = inputs.some(\n                (input) => input?.UnresolvedPure || input?.UnresolvedObject,\n            );\n\n            if (needsResolution) {\n                const functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n                moveFunctionsToResolve.add(functionName);\n                moveCallsToResolve.push(command.MoveCall);\n            }\n        }\n\n        // Special handling for values that where previously encoded using the wellKnownEncoding pattern.\n        // This should only happen when transaction data was hydrated from an old version of the SDK\n        switch (command.$kind) {\n            case 'SplitCoins':\n                command.SplitCoins.amounts.forEach((amount) => {\n                    normalizeRawArgument(amount, bcs.U64, transactionData);\n                });\n                break;\n            case 'TransferObjects':\n                normalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n                break;\n        }\n    });\n\n    const moveFunctionParameters = new Map<string, OpenMoveTypeSignature[]>();\n    if (moveFunctionsToResolve.size > 0) {\n        const client = getClient(options);\n        await Promise.all(\n            [...moveFunctionsToResolve].map(async (functionName) => {\n                const [packageId, moduleId, functionId] = functionName.split('::');\n                const def = await client.getNormalizedMoveFunction({\n                    package: packageId,\n                    module: moduleId,\n                    function: functionId,\n                });\n\n                moveFunctionParameters.set(\n                    functionName,\n                    def.parameters.map((param) => normalizedTypeToMoveTypeSignature(param)),\n                );\n            }),\n        );\n    }\n\n    if (moveCallsToResolve.length) {\n        await Promise.all(\n            moveCallsToResolve.map(async (moveCall) => {\n                const parameters = moveFunctionParameters.get(\n                    `${moveCall.package}::${moveCall.module}::${moveCall.function}`,\n                );\n\n                if (!parameters) {\n                    return;\n                }\n\n                // Entry functions can have a mutable reference to an instance of the TxContext\n                // struct defined in the TxContext module as the last parameter. The caller of\n                // the function does not need to pass it in as an argument.\n                const hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1)!);\n                const params = hasTxContext\n                    ? parameters.slice(0, parameters.length - 1)\n                    : parameters;\n\n                moveCall._argumentTypes = params;\n            }),\n        );\n    }\n\n    commands.forEach((command) => {\n        if (!command.MoveCall) {\n            return;\n        }\n\n        const moveCall = command.MoveCall;\n        const fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n        const params = moveCall._argumentTypes;\n\n        if (!params) {\n            return;\n        }\n\n        if (params.length !== command.MoveCall.arguments.length) {\n            throw new Error(`Incorrect number of arguments for ${fnName}`);\n        }\n\n        params.forEach((param, i) => {\n            const arg = moveCall.arguments[i];\n            if (arg.$kind !== 'Input') return;\n            const input = inputs[arg.Input];\n\n            // Skip if the input is already resolved\n            if (!input.UnresolvedPure && !input.UnresolvedObject) {\n                return;\n            }\n\n            const inputValue =\n                input.UnresolvedPure?.value ?? (input.UnresolvedObject?.objectId as string);\n\n            const inputIndex = inputs.indexOf(input);\n\n            const schema = getPureBcsSchema(param.body);\n            if (schema) {\n                arg.type = 'pure';\n                inputs[inputIndex] = Inputs.Pure(schema.serialize(inputValue));\n                return;\n            }\n\n            if (typeof inputValue !== 'string') {\n                throw new Error(\n                    `Expect the argument to be an object id string, got ${JSON.stringify(\n                        inputValue,\n                        null,\n                        2,\n                    )}`,\n                );\n            }\n\n            arg.type = 'object';\n            const unresolvedObject: typeof input = input.UnresolvedPure\n                ? {\n                      $kind: 'UnresolvedObject',\n                      UnresolvedObject: {\n                          objectId: inputValue,\n                      },\n                  }\n                : input;\n\n            inputs[inputIndex] = unresolvedObject;\n        });\n    });\n}\n\nfunction validate(transactionData: TransactionDataBuilder) {\n    transactionData.inputs.forEach((input, index) => {\n        if (input.$kind !== 'Object' && input.$kind !== 'Pure') {\n            throw new Error(\n                `Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(\n                    input,\n                )}`,\n            );\n        }\n    });\n}\n\nfunction normalizeRawArgument(\n    arg: Argument,\n    schema: BcsType<any>,\n    transactionData: TransactionDataBuilder,\n) {\n    if (arg.$kind !== 'Input') {\n        return;\n    }\n    const input = transactionData.inputs[arg.Input];\n\n    if (input.$kind !== 'UnresolvedPure') {\n        return;\n    }\n\n    transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\n\nfunction isUsedAsMutable(transactionData: TransactionDataBuilder, index: number) {\n    let usedAsMutable = false;\n\n    transactionData.getInputUses(index, (arg, tx) => {\n        if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n            const argIndex = tx.MoveCall.arguments.indexOf(arg);\n            usedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== '&' || usedAsMutable;\n        }\n\n        if (tx.$kind === 'MakeMoveVec' || tx.$kind === 'MergeCoins' || tx.$kind === 'SplitCoins') {\n            usedAsMutable = true;\n        }\n    });\n\n    return usedAsMutable;\n}\n\nfunction isUsedAsReceiving(transactionData: TransactionDataBuilder, index: number) {\n    let usedAsReceiving = false;\n\n    transactionData.getInputUses(index, (arg, tx) => {\n        if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n            const argIndex = tx.MoveCall.arguments.indexOf(arg);\n            usedAsReceiving =\n                isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n        }\n    });\n\n    return usedAsReceiving;\n}\n\nfunction isReceivingType(type: OpenMoveTypeSignature): boolean {\n    if (typeof type.body !== 'object' || !('datatype' in type.body)) {\n        return false;\n    }\n\n    return (\n        type.body.datatype.package === '0x2' &&\n        type.body.datatype.module === 'transfer' &&\n        type.body.datatype.type === 'Receiving'\n    );\n}\n\nexport function getClient(options: BuildTransactionOptions): IotaClient {\n    if (!options.client) {\n        throw new Error(\n            `No iota client passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n        );\n    }\n\n    return options.client;\n}\n\nfunction chunk<T>(arr: T[], size: number): T[][] {\n    return Array.from({ length: Math.ceil(arr.length / size) }, (_, i) =>\n        arr.slice(i * size, i * size + size),\n    );\n}\n"],"names":["chunk", "inputs"],"mappings":"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"}},
    {"offset": {"line": 3618, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/transactions/object.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Transaction, TransactionObjectInput } from './Transaction.js';\n\nexport function createObjectMethods<T>(makeObject: (value: TransactionObjectInput) => T) {\n    function object(value: TransactionObjectInput) {\n        return makeObject(value);\n    }\n\n    object.system = () => object('0x5');\n    object.clock = () => object('0x6');\n    object.random = () => object('0x8');\n    object.denyList = () => object('0x403');\n    object.option =\n        ({ type, value }: { type: string; value: TransactionObjectInput | null }) =>\n        (tx: Transaction) =>\n            tx.moveCall({\n                typeArguments: [type],\n                target: `0x1::option::${value === null ? 'none' : 'some'}`,\n                arguments: value === null ? [] : [tx.object(value)],\n            });\n\n    return object;\n}\n"],"names":[],"mappings":";;;;AAMO,SAAS,oBAAuB,UAAA,EAAkD;IACrF,SAAS,OAAO,KAAA,EAA+B;QAC3C,OAAO,WAAW,KAAK;IAC3B;IAEA,OAAO,MAAA,GAAS,IAAM,OAAO,KAAK;IAClC,OAAO,KAAA,GAAQ,IAAM,OAAO,KAAK;IACjC,OAAO,MAAA,GAAS,IAAM,OAAO,KAAK;IAClC,OAAO,QAAA,GAAW,IAAM,OAAO,OAAO;IACtC,OAAO,MAAA,GACH,CAAC,EAAE,IAAA,EAAM,KAAA,CAAM,CAAA,GACf,CAAC,KACG,GAAG,QAAA,CAAS;gBACR,eAAe;oBAAC,IAAI;iBAAA;gBACpB,QAAQ,CAAA,aAAA,EAAgB,UAAU,OAAO,SAAS,MAAM,EAAA;gBACxD,WAAW,UAAU,OAAO,CAAC,CAAA,GAAI;oBAAC,GAAG,MAAA,CAAO,KAAK,CAAC;iBAAA;YACtD,CAAC;IAET,OAAO;AACX"}},
    {"offset": {"line": 3647, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/transactions/pure.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isSerializedBcs } from '@iota/bcs';\nimport type { BcsType, SerializedBcs } from '@iota/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { Argument } from './data/internal.js';\n\nexport function createPure<T>(makePure: (value: SerializedBcs<any, any> | Uint8Array) => T) {\n    function pure<T extends PureTypeName>(\n        type: T extends PureTypeName ? ValidPureTypeName<T> : T,\n        value: ShapeFromPureTypeName<T>,\n    ): T;\n\n    function pure(\n        /**\n         * The pure value, serialized to BCS. If this is a Uint8Array, then the value\n         * is assumed to be raw bytes, and will be used directly.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        value: SerializedBcs<any, any> | Uint8Array,\n    ): T;\n\n    function pure(\n        typeOrSerializedValue?: PureTypeName | SerializedBcs<any, any> | Uint8Array,\n        value?: unknown,\n    ): T {\n        if (typeof typeOrSerializedValue === 'string') {\n            return makePure(schemaFromName(typeOrSerializedValue).serialize(value as never));\n        }\n\n        if (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {\n            return makePure(typeOrSerializedValue);\n        }\n\n        throw new Error('tx.pure must be called either a bcs type name, or a serialized bcs value');\n    }\n\n    pure.u8 = (value: number) => makePure(bcs.U8.serialize(value));\n    pure.u16 = (value: number) => makePure(bcs.U16.serialize(value));\n    pure.u32 = (value: number) => makePure(bcs.U32.serialize(value));\n    pure.u64 = (value: bigint | number | string) => makePure(bcs.U64.serialize(value));\n    pure.u128 = (value: bigint | number | string) => makePure(bcs.U128.serialize(value));\n    pure.u256 = (value: bigint | number | string) => makePure(bcs.U256.serialize(value));\n    pure.bool = (value: boolean) => makePure(bcs.Bool.serialize(value));\n    pure.string = (value: string) => makePure(bcs.String.serialize(value));\n    pure.address = (value: string) => makePure(bcs.Address.serialize(value));\n    pure.id = pure.address;\n    pure.vector = <Type extends PureTypeName>(\n        type: T extends PureTypeName ? ValidPureTypeName<Type> : Type,\n        value: Iterable<ShapeFromPureTypeName<Type>> & { length: number },\n    ) => {\n        return makePure(bcs.vector(schemaFromName(type as BasePureType)).serialize(value as never));\n    };\n    pure.option = <Type extends PureTypeName>(\n        type: T extends PureTypeName ? ValidPureTypeName<Type> : Type,\n        value: ShapeFromPureTypeName<Type> | null | undefined,\n    ) => {\n        return makePure(bcs.option(schemaFromName(type)).serialize(value as never));\n    };\n\n    return pure;\n}\n\nexport type BasePureType =\n    | 'u8'\n    | 'u16'\n    | 'u32'\n    | 'u64'\n    | 'u128'\n    | 'u256'\n    | 'bool'\n    | 'id'\n    | 'string'\n    | 'address';\n\nexport type PureTypeName = BasePureType | `vector<${string}>` | `option<${string}>`;\nexport type ValidPureTypeName<T extends string> = T extends BasePureType\n    ? PureTypeName\n    : T extends `vector<${infer U}>`\n      ? ValidPureTypeName<U>\n      : T extends `option<${infer U}>`\n        ? ValidPureTypeName<U>\n        : PureTypeValidationError<T>;\n\ntype ShapeFromPureTypeName<T extends PureTypeName> = T extends BasePureType\n    ? Parameters<ReturnType<typeof createPure<Argument>>[T]>[0]\n    : T extends `vector<${infer U extends PureTypeName}>`\n      ? ShapeFromPureTypeName<U>[]\n      : T extends `option<${infer U extends PureTypeName}>`\n        ? ShapeFromPureTypeName<U> | null\n        : never;\n\ntype PureTypeValidationError<T extends string> = T & {\n    error: `Invalid Pure type name: ${T}`;\n};\n\nfunction schemaFromName<T extends PureTypeName>(\n    name: T extends PureTypeName ? ValidPureTypeName<T> : T,\n): BcsType<ShapeFromPureTypeName<T>> {\n    switch (name) {\n        case 'u8':\n            return bcs.u8() as never;\n        case 'u16':\n            return bcs.u16() as never;\n        case 'u32':\n            return bcs.u32() as never;\n        case 'u64':\n            return bcs.u64() as never;\n        case 'u128':\n            return bcs.u128() as never;\n        case 'u256':\n            return bcs.u256() as never;\n        case 'bool':\n            return bcs.bool() as never;\n        case 'string':\n            return bcs.string() as never;\n        case 'id':\n        case 'address':\n            return bcs.Address as never;\n    }\n\n    const generic = name.match(/^(vector|option)<(.+)>$/);\n    if (generic) {\n        const [kind, inner] = generic.slice(1);\n        if (kind === 'vector') {\n            return bcs.vector(schemaFromName(inner as PureTypeName)) as never;\n        } else {\n            return bcs.option(schemaFromName(inner as PureTypeName)) as never;\n        }\n    }\n\n    throw new Error(`Invalid Pure type name: ${name}`);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3722, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/transactions/hash.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { blake2b } from '@noble/hashes/blake2b';\n\n/**\n * Generates a Blake2b hash of typed data as a base64 string.\n *\n * @param typeTag type tag (e.g. TransactionData, SenderSignedData)\n * @param data data to hash\n */\nexport function hashTypedData(typeTag: string, data: Uint8Array): Uint8Array {\n    const typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));\n\n    const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);\n    dataWithTag.set(typeTagBytes);\n    dataWithTag.set(data, typeTagBytes.length);\n\n    return blake2b(dataWithTag, { dkLen: 32 });\n}\n"],"names":[],"mappings":";;;;AAIA,SAAS,eAAe;;AAQjB,SAAS,cAAc,OAAA,EAAiB,IAAA,EAA8B;IACzE,MAAM,eAAe,MAAM,IAAA,CAAK,GAAG,OAAO,CAAA,EAAA,CAAI,EAAE,GAAA,CAAI,CAAC,IAAM,EAAE,UAAA,CAAW,CAAC,CAAC;IAE1E,MAAM,cAAc,IAAI,WAAW,aAAa,MAAA,GAAS,KAAK,MAAM;IACpE,YAAY,GAAA,CAAI,YAAY;IAC5B,YAAY,GAAA,CAAI,MAAM,aAAa,MAAM;IAEzC,WAAO,+NAAA,EAAQ,aAAa;QAAE,OAAO;IAAG,CAAC;AAC7C"}},
    {"offset": {"line": 3743, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/transactions/TransactionData.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase58 } from '@iota/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type {\n    Argument,\n    CallArg,\n    Command,\n    GasData,\n    TransactionExpiration,\n} from './data/internal.js';\nimport { TransactionData } from './data/internal.js';\nimport { transactionDataFromV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV2 } from './data/v2.js';\nimport { hashTypedData } from './hash.js';\n\nfunction prepareIotaAddress(address: string) {\n    return normalizeIotaAddress(address).replace('0x', '');\n}\n\nexport class TransactionDataBuilder implements TransactionData {\n    static fromKindBytes(bytes: Uint8Array) {\n        const kind = bcs.TransactionKind.parse(bytes);\n\n        const programmableTx = kind.ProgrammableTransaction;\n        if (!programmableTx) {\n            throw new Error('Unable to deserialize from bytes.');\n        }\n\n        return TransactionDataBuilder.restore({\n            version: 2,\n            sender: null,\n            expiration: null,\n            gasData: {\n                budget: null,\n                owner: null,\n                payment: null,\n                price: null,\n            },\n            inputs: programmableTx.inputs,\n            commands: programmableTx.commands,\n        });\n    }\n\n    static fromBytes(bytes: Uint8Array) {\n        const rawData = bcs.TransactionData.parse(bytes);\n        const data = rawData?.V1;\n        const programmableTx = data.kind.ProgrammableTransaction;\n\n        if (!data || !programmableTx) {\n            throw new Error('Unable to deserialize from bytes.');\n        }\n\n        return TransactionDataBuilder.restore({\n            version: 2,\n            sender: data.sender,\n            expiration: data.expiration,\n            gasData: data.gasData,\n            inputs: programmableTx.inputs,\n            commands: programmableTx.commands,\n        });\n    }\n\n    static restore(\n        data:\n            | InferInput<typeof SerializedTransactionDataV2>\n            | InferInput<typeof SerializedTransactionDataV1>,\n    ) {\n        if (data.version === 2) {\n            return new TransactionDataBuilder(parse(TransactionData, data));\n        } else {\n            return new TransactionDataBuilder(parse(TransactionData, transactionDataFromV1(data)));\n        }\n    }\n\n    /**\n     * Generate transaction digest.\n     *\n     * @param bytes BCS serialized transaction data\n     * @returns transaction digest.\n     */\n    static getDigestFromBytes(bytes: Uint8Array) {\n        const hash = hashTypedData('TransactionData', bytes);\n        return toBase58(hash);\n    }\n\n    // @deprecated use gasData instead\n    get gasConfig() {\n        return this.gasData;\n    }\n    // @deprecated use gasData instead\n    set gasConfig(value) {\n        this.gasData = value;\n    }\n\n    version = 2 as const;\n    sender: string | null;\n    expiration: TransactionExpiration | null;\n    gasData: GasData;\n    inputs: CallArg[];\n    commands: Command[];\n\n    constructor(clone?: TransactionData) {\n        this.sender = clone?.sender ?? null;\n        this.expiration = clone?.expiration ?? null;\n        this.inputs = clone?.inputs ?? [];\n        this.commands = clone?.commands ?? [];\n        this.gasData = clone?.gasData ?? {\n            budget: null,\n            price: null,\n            owner: null,\n            payment: null,\n        };\n    }\n\n    build({\n        maxSizeBytes = Infinity,\n        overrides,\n        onlyTransactionKind,\n    }: {\n        maxSizeBytes?: number;\n        overrides?: {\n            expiration?: TransactionExpiration;\n            sender?: string;\n            // @deprecated use gasData instead\n            gasConfig?: Partial<GasData>;\n            gasData?: Partial<GasData>;\n        };\n        onlyTransactionKind?: boolean;\n    } = {}) {\n        // TODO validate that inputs and intents are actually resolved\n        const inputs = this.inputs as (typeof bcs.CallArg.$inferInput)[];\n        const commands = this.commands as Extract<\n            Command<Exclude<Argument, { IntentResult: unknown } | { NestedIntentResult: unknown }>>,\n            { Upgrade: unknown }\n        >[];\n\n        const kind = {\n            ProgrammableTransaction: {\n                inputs,\n                commands,\n            },\n        };\n\n        if (onlyTransactionKind) {\n            return bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n        }\n\n        const expiration = overrides?.expiration ?? this.expiration;\n        const sender = overrides?.sender ?? this.sender;\n        const gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };\n\n        if (!sender) {\n            throw new Error('Missing transaction sender');\n        }\n\n        if (!gasData.budget) {\n            throw new Error('Missing gas budget');\n        }\n\n        if (!gasData.payment) {\n            throw new Error('Missing gas payment');\n        }\n\n        if (!gasData.price) {\n            throw new Error('Missing gas price');\n        }\n\n        const transactionData = {\n            sender: prepareIotaAddress(sender),\n            expiration: expiration ? expiration : { None: true },\n            gasData: {\n                payment: gasData.payment,\n                owner: prepareIotaAddress(this.gasData.owner ?? sender),\n                price: BigInt(gasData.price),\n                budget: BigInt(gasData.budget),\n            },\n            kind: {\n                ProgrammableTransaction: {\n                    inputs,\n                    commands,\n                },\n            },\n        };\n\n        return bcs.TransactionData.serialize(\n            { V1: transactionData },\n            { maxSize: maxSizeBytes },\n        ).toBytes();\n    }\n\n    addInput<T extends 'object' | 'pure'>(type: T, arg: CallArg) {\n        const index = this.inputs.length;\n        this.inputs.push(arg);\n        return { Input: index, type, $kind: 'Input' as const };\n    }\n\n    getInputUses(index: number, fn: (arg: Argument, command: Command) => void) {\n        this.mapArguments((arg, command) => {\n            if (arg.$kind === 'Input' && arg.Input === index) {\n                fn(arg, command);\n            }\n\n            return arg;\n        });\n    }\n\n    mapArguments(fn: (arg: Argument, command: Command) => Argument) {\n        for (const command of this.commands) {\n            switch (command.$kind) {\n                case 'MoveCall':\n                    command.MoveCall.arguments = command.MoveCall.arguments.map((arg) =>\n                        fn(arg, command),\n                    );\n                    break;\n                case 'TransferObjects':\n                    command.TransferObjects.objects = command.TransferObjects.objects.map((arg) =>\n                        fn(arg, command),\n                    );\n                    command.TransferObjects.address = fn(command.TransferObjects.address, command);\n                    break;\n                case 'SplitCoins':\n                    command.SplitCoins.coin = fn(command.SplitCoins.coin, command);\n                    command.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) =>\n                        fn(arg, command),\n                    );\n                    break;\n                case 'MergeCoins':\n                    command.MergeCoins.destination = fn(command.MergeCoins.destination, command);\n                    command.MergeCoins.sources = command.MergeCoins.sources.map((arg) =>\n                        fn(arg, command),\n                    );\n                    break;\n                case 'MakeMoveVec':\n                    command.MakeMoveVec.elements = command.MakeMoveVec.elements.map((arg) =>\n                        fn(arg, command),\n                    );\n                    break;\n                case 'Upgrade':\n                    command.Upgrade.ticket = fn(command.Upgrade.ticket, command);\n                    break;\n                case '$Intent':\n                    const inputs = command.$Intent.inputs;\n                    command.$Intent.inputs = {};\n\n                    for (const [key, value] of Object.entries(inputs)) {\n                        command.$Intent.inputs[key] = Array.isArray(value)\n                            ? value.map((arg) => fn(arg, command))\n                            : fn(value, command);\n                    }\n\n                    break;\n                case 'Publish':\n                    break;\n                default:\n                    throw new Error(\n                        `Unexpected transaction kind: ${(command as { $kind: unknown }).$kind}`,\n                    );\n            }\n        }\n    }\n\n    replaceCommand(index: number, replacement: Command | Command[]) {\n        if (!Array.isArray(replacement)) {\n            this.commands[index] = replacement;\n            return;\n        }\n\n        const sizeDiff = replacement.length - 1;\n        this.commands.splice(index, 1, ...replacement);\n\n        if (sizeDiff !== 0) {\n            this.mapArguments((arg) => {\n                switch (arg.$kind) {\n                    case 'Result':\n                        if (arg.Result > index) {\n                            arg.Result += sizeDiff;\n                        }\n                        break;\n\n                    case 'NestedResult':\n                        if (arg.NestedResult[0] > index) {\n                            arg.NestedResult[0] += sizeDiff;\n                        }\n                        break;\n                }\n                return arg;\n            });\n        }\n    }\n\n    getDigest() {\n        const bytes = this.build({ onlyTransactionKind: false });\n        return TransactionDataBuilder.getDigestFromBytes(bytes);\n    }\n\n    snapshot(): TransactionData {\n        return parse(TransactionData, this);\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3991, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/transactions/utils.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { IotaMoveNormalizedType } from '../client/index.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { CallArg } from './data/internal.js';\n\nexport function extractMutableReference(\n    normalizedType: IotaMoveNormalizedType,\n): IotaMoveNormalizedType | undefined {\n    return typeof normalizedType === 'object' && 'MutableReference' in normalizedType\n        ? normalizedType.MutableReference\n        : undefined;\n}\n\nexport function extractReference(\n    normalizedType: IotaMoveNormalizedType,\n): IotaMoveNormalizedType | undefined {\n    return typeof normalizedType === 'object' && 'Reference' in normalizedType\n        ? normalizedType.Reference\n        : undefined;\n}\n\nexport function extractStructTag(\n    normalizedType: IotaMoveNormalizedType,\n): Extract<IotaMoveNormalizedType, { Struct: unknown }> | undefined {\n    if (typeof normalizedType === 'object' && 'Struct' in normalizedType) {\n        return normalizedType;\n    }\n\n    const ref = extractReference(normalizedType);\n    const mutRef = extractMutableReference(normalizedType);\n\n    if (typeof ref === 'object' && 'Struct' in ref) {\n        return ref;\n    }\n\n    if (typeof mutRef === 'object' && 'Struct' in mutRef) {\n        return mutRef;\n    }\n    return undefined;\n}\n\nexport function getIdFromCallArg(arg: string | CallArg) {\n    if (typeof arg === 'string') {\n        return normalizeIotaAddress(arg);\n    }\n\n    if (arg.Object) {\n        if (arg.Object.ImmOrOwnedObject) {\n            return normalizeIotaAddress(arg.Object.ImmOrOwnedObject.objectId);\n        }\n\n        if (arg.Object.Receiving) {\n            return normalizeIotaAddress(arg.Object.Receiving.objectId);\n        }\n\n        return normalizeIotaAddress(arg.Object.SharedObject.objectId);\n    }\n\n    if (arg.UnresolvedObject) {\n        return normalizeIotaAddress(arg.UnresolvedObject.objectId);\n    }\n\n    return undefined;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAKA,SAAS,4BAA4B;;AAG9B,SAAS,wBACZ,cAAA,EACkC;IAClC,OAAO,OAAO,mBAAmB,YAAY,sBAAsB,iBAC7D,eAAe,gBAAA,GACf,KAAA;AACV;AAEO,SAAS,iBACZ,cAAA,EACkC;IAClC,OAAO,OAAO,mBAAmB,YAAY,eAAe,iBACtD,eAAe,SAAA,GACf,KAAA;AACV;AAEO,SAAS,iBACZ,cAAA,EACgE;IAChE,IAAI,OAAO,mBAAmB,YAAY,YAAY,gBAAgB;QAClE,OAAO;IACX;IAEA,MAAM,MAAM,iBAAiB,cAAc;IAC3C,MAAM,SAAS,wBAAwB,cAAc;IAErD,IAAI,OAAO,QAAQ,YAAY,YAAY,KAAK;QAC5C,OAAO;IACX;IAEA,IAAI,OAAO,WAAW,YAAY,YAAY,QAAQ;QAClD,OAAO;IACX;IACA,OAAO,KAAA;AACX;AAEO,SAAS,iBAAiB,GAAA,EAAuB;IACpD,IAAI,OAAO,QAAQ,UAAU;QACzB,WAAO,qSAAA,EAAqB,GAAG;IACnC;IAEA,IAAI,IAAI,MAAA,EAAQ;QACZ,IAAI,IAAI,MAAA,CAAO,gBAAA,EAAkB;YAC7B,WAAO,qSAAA,EAAqB,IAAI,MAAA,CAAO,gBAAA,CAAiB,QAAQ;QACpE;QAEA,IAAI,IAAI,MAAA,CAAO,SAAA,EAAW;YACtB,WAAO,qSAAA,EAAqB,IAAI,MAAA,CAAO,SAAA,CAAU,QAAQ;QAC7D;QAEA,WAAO,qSAAA,EAAqB,IAAI,MAAA,CAAO,YAAA,CAAa,QAAQ;IAChE;IAEA,IAAI,IAAI,gBAAA,EAAkB;QACtB,WAAO,qSAAA,EAAqB,IAAI,gBAAA,CAAiB,QAAQ;IAC7D;IAEA,OAAO,KAAA;AACX"}},
    {"offset": {"line": 4047, "column": 0}, "map": {"version":3,"sources":["file:///home/thanhha/ticket_box/node_modules/.pnpm/%40iota%2Biota-sdk%401.9.0_typescript%405.9.3/node_modules/%40iota/iota-sdk/src/transactions/Transaction.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2024 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@iota/bcs';\nimport { fromBase64, isSerializedBcs } from '@iota/bcs';\nimport type { InferInput } from 'valibot';\nimport { is, parse } from 'valibot';\n\nimport type { IotaClient } from '../client/index.js';\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { normalizeIotaAddress } from '../utils/iota-types.js';\nimport type { TransactionArgument } from './Commands.js';\nimport { Commands } from './Commands.js';\nimport type { CallArg, Command } from './data/internal.js';\nimport { Argument, NormalizedCallArg, ObjectRef, TransactionExpiration } from './data/internal.js';\nimport { serializeV1TransactionData } from './data/v1.js';\nimport { SerializedTransactionDataV2 } from './data/v2.js';\nimport { Inputs } from './Inputs.js';\nimport type {\n    BuildTransactionOptions,\n    SerializeTransactionOptions,\n    TransactionPlugin,\n} from './json-rpc-resolver.js';\nimport { resolveTransactionData } from './json-rpc-resolver.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport { TransactionDataBuilder } from './TransactionData.js';\nimport { getIdFromCallArg } from './utils.js';\n\nexport type TransactionObjectArgument =\n    | Exclude<InferInput<typeof Argument>, { Input: unknown; type?: 'pure' }>\n    | ((\n          tx: Transaction,\n      ) => Exclude<InferInput<typeof Argument>, { Input: unknown; type?: 'pure' }>);\n\nexport type TransactionResult = Extract<Argument, { Result: unknown }> &\n    Extract<Argument, { NestedResult: unknown }>[];\n\nfunction createTransactionResult(index: number) {\n    const baseResult = { $kind: 'Result' as const, Result: index };\n\n    const nestedResults: {\n        $kind: 'NestedResult';\n        NestedResult: [number, number];\n    }[] = [];\n    const nestedResultFor = (\n        resultIndex: number,\n    ): {\n        $kind: 'NestedResult';\n        NestedResult: [number, number];\n    } =>\n        (nestedResults[resultIndex] ??= {\n            $kind: 'NestedResult' as const,\n            NestedResult: [index, resultIndex],\n        });\n\n    return new Proxy(baseResult, {\n        set() {\n            throw new Error(\n                'The transaction result is a proxy, and does not support setting properties directly',\n            );\n        },\n        // TODO: Instead of making this return a concrete argument, we should ideally\n        // make it reference-based (so that this gets resolved at build-time), which\n        // allows re-ordering transactions.\n        get(target, property) {\n            // This allows this transaction argument to be used in the singular form:\n            if (property in target) {\n                return Reflect.get(target, property);\n            }\n\n            // Support destructuring:\n            if (property === Symbol.iterator) {\n                return function* () {\n                    let i = 0;\n                    while (true) {\n                        yield nestedResultFor(i);\n                        i++;\n                    }\n                };\n            }\n\n            if (typeof property === 'symbol') return;\n\n            const resultIndex = parseInt(property, 10);\n            if (Number.isNaN(resultIndex) || resultIndex < 0) return;\n            return nestedResultFor(resultIndex);\n        },\n    }) as TransactionResult;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@iota/transaction') as never;\n\ninterface SignOptions extends BuildTransactionOptions {\n    signer: Signer;\n}\n\nexport function isTransaction(obj: unknown): obj is Transaction {\n    return !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | CallArg | TransactionObjectArgument;\n\ninterface TransactionPluginRegistry {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    buildPlugins: Map<string | Function, TransactionPlugin>;\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    serializationPlugins: Map<string | Function, TransactionPlugin>;\n}\n\nconst modulePluginRegistry: TransactionPluginRegistry = {\n    buildPlugins: new Map(),\n    serializationPlugins: new Map(),\n};\n\nconst TRANSACTION_REGISTRY_KEY = Symbol.for('@iota/transaction/registry');\nfunction getGlobalPluginRegistry() {\n    try {\n        const target = globalThis as {\n            [TRANSACTION_REGISTRY_KEY]?: TransactionPluginRegistry;\n        };\n\n        if (!target[TRANSACTION_REGISTRY_KEY]) {\n            target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n        }\n\n        return target[TRANSACTION_REGISTRY_KEY];\n    } catch (e) {\n        return modulePluginRegistry;\n    }\n}\n\n/**\n * Transaction Builder\n */\nexport class Transaction {\n    #serializationPlugins: TransactionPlugin[];\n    #buildPlugins: TransactionPlugin[];\n    #intentResolvers = new Map<string, TransactionPlugin>();\n\n    /**\n     * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n     * Supports either a byte array, or base64-encoded bytes.\n     */\n    static fromKind(serialized: string | Uint8Array) {\n        const tx = new Transaction();\n\n        tx.#data = TransactionDataBuilder.fromKindBytes(\n            typeof serialized === 'string' ? fromBase64(serialized) : serialized,\n        );\n\n        return tx;\n    }\n\n    /**\n     * Converts from a serialized transaction format to a `Transaction` class.\n     * There are two supported serialized formats:\n     * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n     * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n     */\n    static from(transaction: string | Uint8Array | Transaction) {\n        const newTransaction = new Transaction();\n\n        if (isTransaction(transaction)) {\n            newTransaction.#data = new TransactionDataBuilder(transaction.getData());\n        } else if (typeof transaction !== 'string' || !transaction.startsWith('{')) {\n            newTransaction.#data = TransactionDataBuilder.fromBytes(\n                typeof transaction === 'string' ? fromBase64(transaction) : transaction,\n            );\n        } else {\n            newTransaction.#data = TransactionDataBuilder.restore(JSON.parse(transaction));\n        }\n\n        return newTransaction;\n    }\n\n    /** @deprecated global plugins should be registered with a name */\n    static registerGlobalSerializationPlugin(step: TransactionPlugin): void;\n    static registerGlobalSerializationPlugin(name: string, step: TransactionPlugin): void;\n    static registerGlobalSerializationPlugin(\n        stepOrStep: TransactionPlugin | string,\n        step?: TransactionPlugin,\n    ) {\n        getGlobalPluginRegistry().serializationPlugins.set(\n            stepOrStep,\n            step ?? (stepOrStep as TransactionPlugin),\n        );\n    }\n\n    static unregisterGlobalSerializationPlugin(name: string) {\n        getGlobalPluginRegistry().serializationPlugins.delete(name);\n    }\n\n    /** @deprecated global plugins should be registered with a name */\n    static registerGlobalBuildPlugin(step: TransactionPlugin): void;\n    static registerGlobalBuildPlugin(name: string, step: TransactionPlugin): void;\n    static registerGlobalBuildPlugin(\n        stepOrStep: TransactionPlugin | string,\n        step?: TransactionPlugin,\n    ) {\n        getGlobalPluginRegistry().buildPlugins.set(\n            stepOrStep,\n            step ?? (stepOrStep as TransactionPlugin),\n        );\n    }\n\n    static unregisterGlobalBuildPlugin(name: string) {\n        getGlobalPluginRegistry().buildPlugins.delete(name);\n    }\n\n    addSerializationPlugin(step: TransactionPlugin) {\n        this.#serializationPlugins.push(step);\n    }\n\n    addBuildPlugin(step: TransactionPlugin) {\n        this.#buildPlugins.push(step);\n    }\n\n    addIntentResolver(intent: string, resolver: TransactionPlugin) {\n        if (this.#intentResolvers.has(intent) && this.#intentResolvers.get(intent) !== resolver) {\n            throw new Error(`Intent resolver for ${intent} already exists`);\n        }\n\n        this.#intentResolvers.set(intent, resolver);\n    }\n\n    setSender(sender: string) {\n        this.#data.sender = sender;\n    }\n    /**\n     * Sets the sender only if it has not already been set.\n     * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n     */\n    setSenderIfNotSet(sender: string) {\n        if (!this.#data.sender) {\n            this.#data.sender = sender;\n        }\n    }\n    setExpiration(expiration?: InferInput<typeof TransactionExpiration> | null) {\n        this.#data.expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n    }\n    setGasPrice(price: number | bigint) {\n        this.#data.gasConfig.price = String(price);\n    }\n    setGasBudget(budget: number | bigint) {\n        this.#data.gasConfig.budget = String(budget);\n    }\n\n    setGasBudgetIfNotSet(budget: number | bigint) {\n        if (this.#data.gasData.budget == null) {\n            this.#data.gasConfig.budget = String(budget);\n        }\n    }\n\n    setGasOwner(owner: string) {\n        this.#data.gasConfig.owner = owner;\n    }\n    setGasPayment(payments: ObjectRef[]) {\n        this.#data.gasConfig.payment = payments.map((payment) => parse(ObjectRef, payment));\n    }\n\n    #data: TransactionDataBuilder;\n\n    /** @deprecated Use `getData()` instead. */\n    get blockData() {\n        return serializeV1TransactionData(this.#data.snapshot());\n    }\n\n    /** Get a snapshot of the transaction data, in JSON form: */\n    getData() {\n        return this.#data.snapshot();\n    }\n\n    // Used to brand transaction classes so that they can be identified, even between multiple copies\n    // of the builder.\n    get [TRANSACTION_BRAND]() {\n        return true;\n    }\n\n    // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n    get pure(): ReturnType<typeof createPure<Argument>> {\n        Object.defineProperty(this, 'pure', {\n            enumerable: false,\n            value: createPure<Argument>((value): Argument => {\n                if (isSerializedBcs(value)) {\n                    return this.#data.addInput('pure', {\n                        $kind: 'Pure',\n                        Pure: {\n                            bytes: value.toBase64(),\n                        },\n                    });\n                }\n\n                // TODO: we can also do some deduplication here\n                return this.#data.addInput(\n                    'pure',\n                    is(NormalizedCallArg, value)\n                        ? parse(NormalizedCallArg, value)\n                        : value instanceof Uint8Array\n                          ? Inputs.Pure(value)\n                          : { $kind: 'UnresolvedPure', UnresolvedPure: { value } },\n                );\n            }),\n        });\n\n        return this.pure;\n    }\n\n    constructor() {\n        const globalPlugins = getGlobalPluginRegistry();\n        this.#data = new TransactionDataBuilder();\n        this.#buildPlugins = [...globalPlugins.buildPlugins.values()];\n        this.#serializationPlugins = [...globalPlugins.serializationPlugins.values()];\n    }\n\n    /** Returns an argument for the gas coin, to be used in a transaction. */\n    get gas() {\n        return { $kind: 'GasCoin' as const, GasCoin: true as const };\n    }\n\n    /**\n     * Add a new object input to the transaction.\n     */\n    object = createObjectMethods(\n        (value: TransactionObjectInput): { $kind: 'Input'; Input: number; type?: 'object' } => {\n            if (typeof value === 'function') {\n                return this.object(value(this));\n            }\n\n            if (typeof value === 'object' && is(Argument, value)) {\n                return value as { $kind: 'Input'; Input: number; type?: 'object' };\n            }\n\n            const id = getIdFromCallArg(value);\n\n            const inserted = this.#data.inputs.find((i) => id === getIdFromCallArg(i));\n\n            // Upgrade shared object inputs to mutable if needed:\n            if (\n                inserted?.Object?.SharedObject &&\n                typeof value === 'object' &&\n                value.Object?.SharedObject\n            ) {\n                inserted.Object.SharedObject.mutable =\n                    inserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n            }\n\n            return inserted\n                ? { $kind: 'Input', Input: this.#data.inputs.indexOf(inserted), type: 'object' }\n                : this.#data.addInput(\n                      'object',\n                      typeof value === 'string'\n                          ? {\n                                $kind: 'UnresolvedObject',\n                                UnresolvedObject: { objectId: normalizeIotaAddress(value) },\n                            }\n                          : value,\n                  );\n        },\n    );\n\n    /**\n     * Add a new object input to the transaction using the fully-resolved object reference.\n     * If you only have an object ID, use `builder.object(id)` instead.\n     */\n    objectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n        return this.object(Inputs.ObjectRef(...args));\n    }\n\n    /**\n     * Add a new receiving input to the transaction using the fully-resolved object reference.\n     * If you only have an object ID, use `builder.object(id)` instead.\n     */\n    receivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n        return this.object(Inputs.ReceivingRef(...args));\n    }\n\n    /**\n     * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n     * If you only have an object ID, use `builder.object(id)` instead.\n     */\n    sharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n        return this.object(Inputs.SharedObjectRef(...args));\n    }\n\n    /** Add a transaction to the transaction */\n    add<T = TransactionResult>(command: Command | ((tx: Transaction) => T)): T {\n        if (typeof command === 'function') {\n            return command(this);\n        }\n\n        const index = this.#data.commands.push(command);\n\n        return createTransactionResult(index - 1) as T;\n    }\n\n    #normalizeTransactionArgument(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        arg: TransactionArgument | SerializedBcs<any>,\n    ) {\n        if (isSerializedBcs(arg)) {\n            return this.pure(arg);\n        }\n\n        return this.#resolveArgument(arg as TransactionArgument);\n    }\n\n    #resolveArgument(arg: TransactionArgument): Argument {\n        if (typeof arg === 'function') {\n            return parse(Argument, arg(this));\n        }\n\n        return parse(Argument, arg);\n    }\n\n    // Method shorthands:\n\n    splitCoins(\n        coin: TransactionObjectArgument | string,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        amounts: (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n    ) {\n        return this.add(\n            Commands.SplitCoins(\n                typeof coin === 'string' ? this.object(coin) : this.#resolveArgument(coin),\n                amounts.map((amount) =>\n                    typeof amount === 'number' ||\n                    typeof amount === 'bigint' ||\n                    typeof amount === 'string'\n                        ? this.pure.u64(amount)\n                        : this.#normalizeTransactionArgument(amount),\n                ),\n            ),\n        );\n    }\n    mergeCoins(\n        destination: TransactionObjectArgument | string,\n        sources: (TransactionObjectArgument | string)[],\n    ) {\n        return this.add(\n            Commands.MergeCoins(\n                this.object(destination),\n                sources.map((src) => this.object(src)),\n            ),\n        );\n    }\n    publish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n        return this.add(\n            Commands.Publish({\n                modules,\n                dependencies,\n            }),\n        );\n    }\n    upgrade({\n        modules,\n        dependencies,\n        package: packageId,\n        ticket,\n    }: {\n        modules: number[][] | string[];\n        dependencies: string[];\n        package: string;\n        ticket: TransactionObjectArgument | string;\n    }) {\n        return this.add(\n            Commands.Upgrade({\n                modules,\n                dependencies,\n                package: packageId,\n                ticket: this.object(ticket),\n            }),\n        );\n    }\n    moveCall({\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        arguments: args,\n        ...input\n    }:\n        | {\n              package: string;\n              module: string;\n              function: string;\n              arguments?: (TransactionArgument | SerializedBcs<any>)[];\n              typeArguments?: string[];\n          }\n        | {\n              target: string;\n              arguments?: (TransactionArgument | SerializedBcs<any>)[];\n              typeArguments?: string[];\n          }) {\n        return this.add(\n            Commands.MoveCall({\n                ...input,\n                arguments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n            } as Parameters<typeof Commands.MoveCall>[0]),\n        );\n    }\n    transferObjects(\n        objects: (TransactionObjectArgument | string)[],\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        address: TransactionArgument | SerializedBcs<any> | string,\n    ) {\n        return this.add(\n            Commands.TransferObjects(\n                objects.map((obj) => this.object(obj)),\n                typeof address === 'string'\n                    ? this.pure.address(address)\n                    : this.#normalizeTransactionArgument(address),\n            ),\n        );\n    }\n    makeMoveVec({\n        type,\n        elements,\n    }: {\n        elements: (TransactionObjectArgument | string)[];\n        type?: string;\n    }) {\n        return this.add(\n            Commands.MakeMoveVec({\n                type,\n                elements: elements.map((obj) => this.object(obj)),\n            }),\n        );\n    }\n\n    /**\n     * @deprecated Use toJSON instead.\n     * For synchronous serialization, you can use `getData()`\n     * */\n    serialize() {\n        return JSON.stringify(serializeV1TransactionData(this.#data.snapshot()));\n    }\n\n    async toJSON(options: SerializeTransactionOptions = {}): Promise<string> {\n        await this.prepareForSerialization(options);\n        return JSON.stringify(\n            parse(SerializedTransactionDataV2, this.#data.snapshot()),\n            (_key, value) => (typeof value === 'bigint' ? value.toString() : value),\n            2,\n        );\n    }\n\n    /** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n    async sign(options: SignOptions): Promise<SignatureWithBytes> {\n        const { signer, ...buildOptions } = options;\n        const bytes = await this.build(buildOptions);\n        return signer.signTransaction(bytes);\n    }\n\n    /** Build the transaction to BCS bytes. */\n    async build(options: BuildTransactionOptions = {}): Promise<Uint8Array> {\n        await this.prepareForSerialization(options);\n        await this.#prepareBuild(options);\n        return this.#data.build({\n            maxSizeBytes: options.maxSizeBytes,\n            onlyTransactionKind: options.onlyTransactionKind,\n        });\n    }\n\n    /** Derive transaction digest */\n    async getDigest(\n        options: {\n            client?: IotaClient;\n        } = {},\n    ): Promise<string> {\n        await this.#prepareBuild(options);\n        return this.#data.getDigest();\n    }\n\n    /**\n     * Prepare the transaction by validating the transaction data and resolving all inputs\n     * so that it can be built into bytes.\n     */\n    async #prepareBuild(options: BuildTransactionOptions) {\n        if (!options.onlyTransactionKind && !this.#data.sender) {\n            throw new Error('Missing transaction sender');\n        }\n\n        await this.#runPlugins([...this.#buildPlugins, resolveTransactionData], options);\n    }\n\n    async #runPlugins(plugins: TransactionPlugin[], options: SerializeTransactionOptions) {\n        const createNext = (i: number) => {\n            if (i >= plugins.length) {\n                return () => {};\n            }\n            const plugin = plugins[i];\n\n            return async () => {\n                const next = createNext(i + 1);\n                let calledNext = false;\n                let nextResolved = false;\n\n                await plugin(this.#data, options, async () => {\n                    if (calledNext) {\n                        throw new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n                    }\n\n                    calledNext = true;\n\n                    await next();\n\n                    nextResolved = true;\n                });\n\n                if (!calledNext) {\n                    throw new Error(`next() was not called in TransactionPlugin ${i}`);\n                }\n\n                if (!nextResolved) {\n                    throw new Error(`next() was not awaited in TransactionPlugin ${i}`);\n                }\n            };\n        };\n\n        await createNext(0)();\n    }\n\n    async prepareForSerialization(options: SerializeTransactionOptions) {\n        const intents = new Set<string>();\n        for (const command of this.#data.commands) {\n            if (command.$Intent) {\n                intents.add(command.$Intent.name);\n            }\n        }\n\n        const steps = [...this.#serializationPlugins];\n\n        for (const intent of intents) {\n            if (options.supportedIntents?.includes(intent)) {\n                continue;\n            }\n\n            if (!this.#intentResolvers.has(intent)) {\n                throw new Error(`Missing intent resolver for ${intent}`);\n            }\n\n            steps.push(this.#intentResolvers.get(intent)!);\n        }\n\n        await this.#runPlugins(steps, options);\n    }\n}\n"],"names":[],"mappings":"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"}}]
}