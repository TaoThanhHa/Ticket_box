**IMPORTANT: Return ONLY the two code files. No explanations, no commentary, just the code.**

I am customizing an IOTA dApp built with Next.js, React, and TypeScript. Update the contract integration hook and UI component.

## Contract Details

- **Network:** `devnet`
- **Package ID:** `0xb5be25b68c9cfc7d9c5ff2d295e42162d063e4b1c0b209229e1eaf328dfaca03`
- **Module Name:** `ticket_box::ticket`
- **Available Methods:**

  * `create_ticket` (constant: `CREATE_TICKET`)
  * `claim_ticket` (constant: `CLAIM_TICKET`)

---

# **Move Contract: `contract/ticket_contract/sources/ticket_box.move`**

```move
module ticket_box::ticket {
use std::vector;
use iota::object;
use iota::tx_context;
use iota::transfer;
public struct Ticket has store {
event_name: vector<u8>,
date: vector<u8>,
seat: vector<u8>,
price: u64,
}
public struct TicketBox has key, store {
id: object::UID,
ticket: Ticket,
}
public struct Claim has key, store {
id: object::UID,
user: address,
}
public entry fun create_ticket(
event_name: vector<u8>,
date: vector<u8>,
seat: vector<u8>,
price: u64,
ctx: &mut tx_context::TxContext
) {
let sender = tx_context::sender(ctx);
let t = Ticket {
event_name,
date,
seat,
price,
};
transfer::public_transfer(
TicketBox { id: object::new(ctx), ticket: t },
sender
);
}
public entry fun claim_ticket(
ticket_box: &TicketBox,
ctx: &mut tx_context::TxContext
) {
let user = tx_context::sender(ctx);
transfer::public_transfer(
Claim { id: object::new(ctx), user },
user
);
}
}
```

---

# File 1: `hooks/useContract.ts`

```ts
"use client";

import { useState } from "react";
import {
  useCurrentAccount,
  useIotaClient,
  useSignAndExecuteTransaction,
  useIotaClientQuery,
} from "@iota/dapp-kit";

import { Transaction } from "@iota/iota-sdk/transactions";
import { useNetworkVariable } from "@/lib/config";
import type { IotaObjectData } from "@iota/iota-sdk/client";

export const CONTRACT_MODULE = "ticket_box::ticket";
export const CONTRACT_METHODS = {
  CREATE: "create_ticket",
  CLAIM: "claim_ticket",
} as const;

// Hard-coded event used for minting (you can change)
const DEFAULT_EVENT = {
  name: "Music Festival 2025",
  date: "2025-12-01",
  seat: "A12",
  price: 50,
};

function bytesToString(v: number[] | Uint8Array): string {
  try {
    if (v instanceof Uint8Array) return new TextDecoder().decode(v);
    return new TextDecoder().decode(new Uint8Array(v));
  } catch {
    return String.fromCharCode(...(v as number[]));
  }
}

function getTicketBoxFields(data: IotaObjectData): any | null {
  if (data.content?.dataType !== "moveObject") return null;

  const fields = data.content.fields as Record<string, any>;
  if (!fields.ticket) return null;

  const t = fields.ticket as any;

  return {
    eventName: bytesToString(t.event_name),
    date: bytesToString(t.date),
    seat: bytesToString(t.seat),
    price: Number(t.price),
  };
}

export const useContract = () => {
  const currentAccount = useCurrentAccount();
  const address = currentAccount?.address;
  const packageId = useNetworkVariable("packageId");
  const iotaClient = useIotaClient();
  const { mutate: signAndExecute, isPending } =
    useSignAndExecuteTransaction();

  const [ticketBoxId, setTicketBoxId] = useState<string | null>(() =>
    typeof window !== "undefined" && address
      ? localStorage.getItem(`ticketBoxId_${address}`)
      : null
  );

  const [claimId, setClaimId] = useState<string | null>(() =>
    typeof window !== "undefined" && address
      ? localStorage.getItem(`claimId_${address}`)
      : null
  );

  const [isLoading, setIsLoading] = useState(false);
  const [hash, setHash] = useState<string | undefined>();
  const [txError, setTxError] = useState<Error | null>(null);

  const {
    data,
    isPending: isFetching,
    error: queryError,
    refetch,
  } = useIotaClientQuery(
    "getObject",
    { id: ticketBoxId!, options: { showContent: true, showOwner: true } },
    { enabled: !!ticketBoxId }
  );

  const fields = data?.data ? getTicketBoxFields(data.data) : null;

  // --------------------------
  // CREATE TICKET â€” user enters buyer info, but Move expects only event fields
  // We therefore pass only the 4 expected args to moveCall and save buyer off-chain.
  // --------------------------
  const createTicket = async (
    buyerName: string,
    buyerEmail: string,
    buyerPhone: string
  ) => {
    if (!packageId) {
      setTxError(new Error("Missing packageId in config"));
      return;
    }

    try {
      setTxError(null);

      const tx = new Transaction();
      // build call: only event_name, date, seat, price (Move signature)
      tx.moveCall({
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.CREATE}`,
        arguments: [
          tx.pure.vector("u8", Array.from(new TextEncoder().encode(DEFAULT_EVENT.name))),
          tx.pure.vector("u8", Array.from(new TextEncoder().encode(DEFAULT_EVENT.date))),
          tx.pure.vector("u8", Array.from(new TextEncoder().encode(DEFAULT_EVENT.seat))),
          tx.pure.u64(DEFAULT_EVENT.price),
        ],
      });

      signAndExecute(
        { transaction: tx as never },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest);
            setIsLoading(true);

            try {
              const { effects } = await iotaClient.waitForTransaction({
                digest,
                options: { showEffects: true },
              });

              const created = effects?.created ?? [];

              // find newly created TicketBox object owned by current address
              const newObj = created.find(
                (c) =>
                  typeof c.owner === "object" &&
                  c.owner !== null &&
                  "AddressOwner" in c.owner &&
                  c.owner.AddressOwner === address
              );

              const newId = newObj?.reference?.objectId;

              if (newId) {
                setTicketBoxId(newId);
                if (address) localStorage.setItem(`ticketBoxId_${address}`, newId);

                // Save buyer info off-chain mapped to this ticketBoxId
                try {
                  const booking = {
                    ticketBoxId: newId,
                    buyer: { name: buyerName, email: buyerEmail, phone: buyerPhone },
                    event: DEFAULT_EVENT,
                    createdAt: new Date().toISOString(),
                    txDigest: digest,
                  };
                  localStorage.setItem(`booking_${newId}`, JSON.stringify(booking));
                } catch {
                  // ignore storage error
                }

                await refetch();
              }
            } finally {
              setIsLoading(false);
            }
          },
          onError: (err) => {
            setTxError(err instanceof Error ? err : new Error(String(err)));
          },
        }
      );
    } catch (err) {
      setTxError(err instanceof Error ? err : new Error(String(err)));
    }
  };

  // --------------------------
  // CLAIM TICKET
  // --------------------------
  const claimTicket = async () => {
    if (!ticketBoxId || !packageId) return;

    try {
      setTxError(null);

      const tx = new Transaction();
      tx.moveCall({
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.CLAIM}`,
        arguments: [tx.object(ticketBoxId)],
      });

      signAndExecute(
        { transaction: tx as never },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest);
            setIsLoading(true);

            try {
              const { effects } = await iotaClient.waitForTransaction({
                digest,
                options: { showEffects: true },
              });

              const created = effects?.created ?? [];

              const newObj = created.find(
                (c) =>
                  typeof c.owner === "object" &&
                  c.owner !== null &&
                  "AddressOwner" in c.owner &&
                  c.owner.AddressOwner === address
              );

              const newId = newObj?.reference?.objectId;

              if (newId) {
                setClaimId(newId);
                if (address) localStorage.setItem(`claimId_${address}`, newId);

                // also map claim => ticketBox (handy)
                try {
                  localStorage.setItem(`claim_to_ticket_${newId}`, ticketBoxId ?? "");
                } catch {}
              }

              await refetch();
            } finally {
              setIsLoading(false);
            }
          },
          onError: (err) => {
            setTxError(err instanceof Error ? err : new Error(String(err)));
          },
        }
      );
    } catch (err) {
      setTxError(err instanceof Error ? err : new Error(String(err)));
    }
  };

  return {
    data: fields,
    ticketBoxId,
    claimId,
    actions: { createTicket, claimTicket },
    state: {
      isLoading,
      isPending,
      hash,
      isConfirmed: !!hash && !isLoading && !isPending,
      error: txError || queryError,
    },
    hasValidData: !!fields,
    isFetching,
  };
};

```

---

# File 2: `components/sample.tsx`

```tsx
"use client";

import { useEffect, useState } from "react";
import { useContract } from "../hooks/useContract";
import { QRCodeSVG } from "qrcode.react";

export default function SampleBooking() {
  const { actions, state, ticketBoxId, claimId, data } = useContract() as any;

  const DEFAULT_EVENT = {
    eventName: "Music Festival 2025",
    date: "2025-12-01",
    seat: "A12",
    price: 50,
  };

  // buyer form
  const [buyer, setBuyer] = useState({ name: "", email: "", phone: "" });
  const [error, setError] = useState<string | null>(null);
  const [createdTicketId, setCreatedTicketId] = useState<string | null>(null);
  const [bookingData, setBookingData] = useState<any | null>(null);

  // when ticketBoxId changes (created), load booking info from localStorage
  useEffect(() => {
    if (!ticketBoxId) return;
    setCreatedTicketId(ticketBoxId);
    try {
      const raw = localStorage.getItem(`booking_${ticketBoxId}`);
      if (raw) setBookingData(JSON.parse(raw));
    } catch {}
  }, [ticketBoxId]);

  // when claimId set, try to assemble QR payload
  const [qrPayload, setQrPayload] = useState<string | null>(null);
  useEffect(() => {
    if (!claimId) return;
    // find ticket id mapped to this claim if any
    try {
      const ticketForClaim = localStorage.getItem(`claim_to_ticket_${claimId}`);
      const bookingRaw = ticketForClaim ? localStorage.getItem(`booking_${ticketForClaim}`) : null;
      const booking = bookingRaw ? JSON.parse(bookingRaw) : bookingData;

      const payload = {
        claimId,
        ticketBoxId: ticketForClaim ?? ticketBoxId,
        buyer: booking?.buyer ?? { name: "", email: "", phone: "" },
        event: booking?.event ?? DEFAULT_EVENT,
      };
      setQrPayload(JSON.stringify(payload));
    } catch {
      setQrPayload(JSON.stringify({ claimId, ticketBoxId, buyer: bookingData?.buyer ?? buyer }));
    }
  }, [claimId, bookingData, ticketBoxId, buyer]);

  const validateBuyer = () => {
    if (!buyer.name.trim()) return "Vui lÃ²ng nháº­p tÃªn.";
    const emailRe = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRe.test(buyer.email)) return "Email khÃ´ng há»£p lá»‡.";
    const phoneDigits = buyer.phone.replace(/\D/g, "");
    if (phoneDigits.length < 7) return "Sá»‘ Ä‘iá»‡n thoáº¡i ngáº¯n quÃ¡.";
    return null;
  };

  const handleCreate = async () => {
    setError(null);
    const v = validateBuyer();
    if (v) {
      setError(v);
      return;
    }
    try {
      await actions.createTicket(buyer.name, buyer.email, buyer.phone);
    } catch (err: any) {
      setError(err?.message || String(err));
    }
  };

  const handleClaim = async () => {
    try {
      await actions.claimTicket();
    } catch (err: any) {
      setError(err?.message || String(err));
    }
  };

  return (
    <div className="min-h-screen bg-black text-white flex items-center justify-center p-6">
      <div className="w-full max-w-lg bg-neutral-900/90 rounded-[50px] p-8 shadow-2xl border border-neutral-800">
        <h1 className="text-3xl font-bold mb-6 text-center text-blue-400">ðŸŽ« Booking Ticket</h1>

        <div className="mb-6 bg-neutral-800 p-5 rounded-3xl border border-neutral-700">
          <h2 className="text-xl font-semibold mb-2">Event Details</h2>
          <p><b>Event:</b> {DEFAULT_EVENT.eventName}</p>
          <p><b>Date:</b> {DEFAULT_EVENT.date}</p>
          <p><b>Seat:</b> {DEFAULT_EVENT.seat}</p>
          <p><b>Price:</b> {DEFAULT_EVENT.price} MIOTA</p>
        </div>

        <div className="bg-neutral-800 p-5 rounded-3xl border border-neutral-700 mb-4">
          <h2 className="text-xl font-semibold mb-4">Buyer Information</h2>
          <div className="space-y-4">
            <input className="w-full bg-neutral-700 p-3 rounded-2xl text-white focus:ring focus:ring-blue-500 outline-none"
              placeholder="Name" value={buyer.name} onChange={(e) => setBuyer({ ...buyer, name: e.target.value })} />
            <input className="w-full bg-neutral-700 p-3 rounded-2xl text-white focus:ring focus:ring-blue-500 outline-none"
              placeholder="Email" value={buyer.email} onChange={(e) => setBuyer({ ...buyer, email: e.target.value })} />
            <input className="w-full bg-neutral-700 p-3 rounded-2xl text-white focus:ring focus:ring-blue-500 outline-none"
              placeholder="Phone" value={buyer.phone} onChange={(e) => setBuyer({ ...buyer, phone: e.target.value })} />

            <button onClick={handleCreate}
              disabled={state?.isLoading || state?.isPending}
              className="w-full bg-blue-600 text-white py-3 rounded-2xl text-lg font-semibold hover:bg-blue-700 transition disabled:bg-gray-500">
              {state?.isPending ? "Processing..." : "Create Ticket"}
            </button>

            {error && <p className="text-red-500">{error}</p>}
          </div>
        </div>

        {/* After creation show ticketBoxId and allow claim */}
        {createdTicketId && (
          <div className="mb-4 bg-neutral-800 p-4 rounded-xl border border-neutral-700">
            <p className="text-sm text-gray-300">TicketBox ID:</p>
            <p className="font-mono break-words">{createdTicketId}</p>
            <div className="mt-3 flex gap-2">
              <button onClick={handleClaim}
                className="px-4 py-2 bg-green-600 rounded-lg hover:bg-green-700">Claim Ticket</button>
              <button onClick={() => {
                try { navigator.clipboard.writeText(createdTicketId); } catch {}
              }} className="px-4 py-2 bg-gray-700 rounded-lg">Copy ID</button>
            </div>
          </div>
        )}

        {/* After claim show QR */}
        {claimId && qrPayload && (
          <div className="mt-4 bg-neutral-800 p-4 rounded-xl border border-neutral-700 text-center">
            <p className="mb-2 text-sm text-gray-300">Claim ID</p>
            <p className="font-mono break-words mb-3">{claimId}</p>
            <div className="mx-auto w-48 h-48 bg-white p-2 inline-block rounded-lg">
              <QRCodeSVG value={qrPayload} size={180} />
            </div>
            <p className="mt-3 text-sm text-gray-300">Scan this QR at the event.</p>
          </div>
        )}
      </div>
    </div>
  );
}

```

---

# Your Task

Return **two updated files**:

## 1. `hooks/useContract.ts`

- Keep all TypeScript interfaces
- Preserve loading, error, and transaction state logic
- Maintain hook object structure
- Keep contract calls functional
- Use Package ID: `0xb5be25b68c9cfc7d9c5ff2d295e42162d063e4b1c0b209229e1eaf328dfaca03` and Module: `ticket_box::ticket`
- Only implement requested changes

## 2. `components/sample.tsx`

- Keep UI behavior and wallet checks
- Preserve loading, error, object state and transaction UI
- Maintain interaction logic unless specified
- Apply only requested modifications
